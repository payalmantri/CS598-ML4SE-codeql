{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java", "func_name": "RelationalOperationsMatrix.setPredicates_", "original_string": "private void setPredicates_(String scl) {\n\t\tm_scl = scl;\n\n\t\tfor (int i = 0; i < 9; i++) {\n\t\t\tif (m_scl.charAt(i) != '*') {\n\t\t\t\tm_perform_predicates[i] = true;\n\t\t\t\tm_predicate_count++;\n\t\t\t} else\n\t\t\t\tm_perform_predicates[i] = false;\n\t\t}\n\t}", "language": "java", "code": "private void setPredicates_(String scl) {\n\t\tm_scl = scl;\n\n\t\tfor (int i = 0; i < 9; i++) {\n\t\t\tif (m_scl.charAt(i) != '*') {\n\t\t\t\tm_perform_predicates[i] = true;\n\t\t\t\tm_predicate_count++;\n\t\t\t} else\n\t\t\t\tm_perform_predicates[i] = false;\n\t\t}\n\t}", "code_tokens": ["private", "void", "setPredicates_", "(", "String", "scl", ")", "{", "m_scl", "=", "scl", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "9", ";", "i", "++", ")", "{", "if", "(", "m_scl", ".", "charAt", "(", "i", ")", "!=", "'", "'", ")", "{", "m_perform_predicates", "[", "i", "]", "=", "true", ";", "m_predicate_count", "++", ";", "}", "else", "m_perform_predicates", "[", "i", "]", "=", "false", ";", "}", "}"], "docstring": "Sets the relation predicates from the scl string.", "docstring_tokens": ["Sets", "the", "relation", "predicates", "from", "the", "scl", "string", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java#L1360-L1370", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/ConvexHull.java", "func_name": "ConvexHull.getBoundingGeometry", "original_string": "Geometry getBoundingGeometry() {\n\t\t// Extracts the convex hull from the tree. Reading the tree in order from first to last is the resulting convex hull.\n\t\tPoint point = new Point();\n\t\tint first = m_tree_hull.getFirst(-1);\n\t\tPolygon hull = new Polygon(m_shape.getVertexDescription());\n\t\tif (m_tree_hull.size(-1) == 0)\n\t\t\treturn hull;\n\t\t\n\t\tm_shape.queryPoint(m_tree_hull.getElement(first), point);\n\t\thull.startPath(point);\n\n\t\tfor (int i = m_tree_hull.getNext(first); i != -1; i = m_tree_hull.getNext(i)) {\n\t\t\tm_shape.queryPoint(m_tree_hull.getElement(i), point);\n\t\t\thull.lineTo(point);\n\t\t}\n\n\t\treturn hull;\n\t}", "language": "java", "code": "Geometry getBoundingGeometry() {\n\t\t// Extracts the convex hull from the tree. Reading the tree in order from first to last is the resulting convex hull.\n\t\tPoint point = new Point();\n\t\tint first = m_tree_hull.getFirst(-1);\n\t\tPolygon hull = new Polygon(m_shape.getVertexDescription());\n\t\tif (m_tree_hull.size(-1) == 0)\n\t\t\treturn hull;\n\t\t\n\t\tm_shape.queryPoint(m_tree_hull.getElement(first), point);\n\t\thull.startPath(point);\n\n\t\tfor (int i = m_tree_hull.getNext(first); i != -1; i = m_tree_hull.getNext(i)) {\n\t\t\tm_shape.queryPoint(m_tree_hull.getElement(i), point);\n\t\t\thull.lineTo(point);\n\t\t}\n\n\t\treturn hull;\n\t}", "code_tokens": ["Geometry", "getBoundingGeometry", "(", ")", "{", "// Extracts the convex hull from the tree. Reading the tree in order from first to last is the resulting convex hull.", "Point", "point", "=", "new", "Point", "(", ")", ";", "int", "first", "=", "m_tree_hull", ".", "getFirst", "(", "-", "1", ")", ";", "Polygon", "hull", "=", "new", "Polygon", "(", "m_shape", ".", "getVertexDescription", "(", ")", ")", ";", "if", "(", "m_tree_hull", ".", "size", "(", "-", "1", ")", "==", "0", ")", "return", "hull", ";", "m_shape", ".", "queryPoint", "(", "m_tree_hull", ".", "getElement", "(", "first", ")", ",", "point", ")", ";", "hull", ".", "startPath", "(", "point", ")", ";", "for", "(", "int", "i", "=", "m_tree_hull", ".", "getNext", "(", "first", ")", ";", "i", "!=", "-", "1", ";", "i", "=", "m_tree_hull", ".", "getNext", "(", "i", ")", ")", "{", "m_shape", ".", "queryPoint", "(", "m_tree_hull", ".", "getElement", "(", "i", ")", ",", "point", ")", ";", "hull", ".", "lineTo", "(", "point", ")", ";", "}", "return", "hull", ";", "}"], "docstring": "Gets the current bounding geometry.\nReturns a Geometry.", "docstring_tokens": ["Gets", "the", "current", "bounding", "geometry", ".", "Returns", "a", "Geometry", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/ConvexHull.java#L81-L98", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/EditShape.java", "func_name": "EditShape.getEnvelope2D", "original_string": "Envelope2D getEnvelope2D() {\n\t\tEnvelope2D env = new Envelope2D();\n\t\tenv.setEmpty();\n\t\tVertexIterator vert_iter = queryVertexIterator();\n\t\tPoint2D pt = new Point2D();\n\t\tboolean b_first = true;\n\t\tfor (int ivertex = vert_iter.next(); ivertex != -1; ivertex = vert_iter\n\t\t\t\t.next()) {\n\t\t\tgetXY(ivertex, pt);\n\t\t\tif (b_first)\n\t\t\t\tenv.merge(pt.x, pt.y);\n\t\t\telse\n\t\t\t\tenv.mergeNE(pt.x, pt.y);\n\n\t\t\tb_first = false;\n\t\t}\n\n\t\treturn env;\n\t}", "language": "java", "code": "Envelope2D getEnvelope2D() {\n\t\tEnvelope2D env = new Envelope2D();\n\t\tenv.setEmpty();\n\t\tVertexIterator vert_iter = queryVertexIterator();\n\t\tPoint2D pt = new Point2D();\n\t\tboolean b_first = true;\n\t\tfor (int ivertex = vert_iter.next(); ivertex != -1; ivertex = vert_iter\n\t\t\t\t.next()) {\n\t\t\tgetXY(ivertex, pt);\n\t\t\tif (b_first)\n\t\t\t\tenv.merge(pt.x, pt.y);\n\t\t\telse\n\t\t\t\tenv.mergeNE(pt.x, pt.y);\n\n\t\t\tb_first = false;\n\t\t}\n\n\t\treturn env;\n\t}", "code_tokens": ["Envelope2D", "getEnvelope2D", "(", ")", "{", "Envelope2D", "env", "=", "new", "Envelope2D", "(", ")", ";", "env", ".", "setEmpty", "(", ")", ";", "VertexIterator", "vert_iter", "=", "queryVertexIterator", "(", ")", ";", "Point2D", "pt", "=", "new", "Point2D", "(", ")", ";", "boolean", "b_first", "=", "true", ";", "for", "(", "int", "ivertex", "=", "vert_iter", ".", "next", "(", ")", ";", "ivertex", "!=", "-", "1", ";", "ivertex", "=", "vert_iter", ".", "next", "(", ")", ")", "{", "getXY", "(", "ivertex", ",", "pt", ")", ";", "if", "(", "b_first", ")", "env", ".", "merge", "(", "pt", ".", "x", ",", "pt", ".", "y", ")", ";", "else", "env", ".", "mergeNE", "(", "pt", ".", "x", ",", "pt", ".", "y", ")", ";", "b_first", "=", "false", ";", "}", "return", "env", ";", "}"], "docstring": "Returns envelope of all coordinates.", "docstring_tokens": ["Returns", "envelope", "of", "all", "coordinates", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/EditShape.java#L549-L567", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/JsonParserReader.java", "func_name": "JsonParserReader.createFromStringNNT", "original_string": "public static JsonReader createFromStringNNT(String str) {\n\t\ttry {\n\t\t\tJsonFactory factory = new JsonFactory();\n\t\t\tJsonParser jsonParser = factory.createParser(str);\n\t\n\t\t\treturn new JsonParserReader(jsonParser);\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tthrow new JsonGeometryException(ex.getMessage());\n\t\t}\n\t}", "language": "java", "code": "public static JsonReader createFromStringNNT(String str) {\n\t\ttry {\n\t\t\tJsonFactory factory = new JsonFactory();\n\t\t\tJsonParser jsonParser = factory.createParser(str);\n\t\n\t\t\treturn new JsonParserReader(jsonParser);\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tthrow new JsonGeometryException(ex.getMessage());\n\t\t}\n\t}", "code_tokens": ["public", "static", "JsonReader", "createFromStringNNT", "(", "String", "str", ")", "{", "try", "{", "JsonFactory", "factory", "=", "new", "JsonFactory", "(", ")", ";", "JsonParser", "jsonParser", "=", "factory", ".", "createParser", "(", "str", ")", ";", "return", "new", "JsonParserReader", "(", "jsonParser", ")", ";", "}", "catch", "(", "Exception", "ex", ")", "{", "throw", "new", "JsonGeometryException", "(", "ex", ".", "getMessage", "(", ")", ")", ";", "}", "}"], "docstring": "Creates a JsonReader for the string.\nThe nextToken is not called by this method.", "docstring_tokens": ["Creates", "a", "JsonReader", "for", "the", "string", ".", "The", "nextToken", "is", "not", "called", "by", "this", "method", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/JsonParserReader.java#L62-L72", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/GeometryEngine.java", "func_name": "GeometryEngine.intersect", "original_string": "static Geometry[] intersect(Geometry[] inputGeometries, Geometry geometry,\n\t\t\tSpatialReference spatialReference) {\n\t\tOperatorIntersection op = (OperatorIntersection) factory\n\t\t\t\t.getOperator(Operator.Type.Intersection);\n\t\tSimpleGeometryCursor inputGeometriesCursor = new SimpleGeometryCursor(\n\t\t\t\tinputGeometries);\n\t\tSimpleGeometryCursor intersectorCursor = new SimpleGeometryCursor(\n\t\t\t\tgeometry);\n\t\tGeometryCursor result = op.execute(inputGeometriesCursor,\n\t\t\t\tintersectorCursor, spatialReference, null);\n\n\t\tArrayList<Geometry> resultGeoms = new ArrayList<Geometry>();\n\t\tGeometry g;\n\t\twhile ((g = result.next()) != null) {\n\t\t\tresultGeoms.add(g);\n\t\t}\n\n\t\tGeometry[] resultarr = resultGeoms.toArray(new Geometry[0]);\n\t\treturn resultarr;\n\t}", "language": "java", "code": "static Geometry[] intersect(Geometry[] inputGeometries, Geometry geometry,\n\t\t\tSpatialReference spatialReference) {\n\t\tOperatorIntersection op = (OperatorIntersection) factory\n\t\t\t\t.getOperator(Operator.Type.Intersection);\n\t\tSimpleGeometryCursor inputGeometriesCursor = new SimpleGeometryCursor(\n\t\t\t\tinputGeometries);\n\t\tSimpleGeometryCursor intersectorCursor = new SimpleGeometryCursor(\n\t\t\t\tgeometry);\n\t\tGeometryCursor result = op.execute(inputGeometriesCursor,\n\t\t\t\tintersectorCursor, spatialReference, null);\n\n\t\tArrayList<Geometry> resultGeoms = new ArrayList<Geometry>();\n\t\tGeometry g;\n\t\twhile ((g = result.next()) != null) {\n\t\t\tresultGeoms.add(g);\n\t\t}\n\n\t\tGeometry[] resultarr = resultGeoms.toArray(new Geometry[0]);\n\t\treturn resultarr;\n\t}", "code_tokens": ["static", "Geometry", "[", "]", "intersect", "(", "Geometry", "[", "]", "inputGeometries", ",", "Geometry", "geometry", ",", "SpatialReference", "spatialReference", ")", "{", "OperatorIntersection", "op", "=", "(", "OperatorIntersection", ")", "factory", ".", "getOperator", "(", "Operator", ".", "Type", ".", "Intersection", ")", ";", "SimpleGeometryCursor", "inputGeometriesCursor", "=", "new", "SimpleGeometryCursor", "(", "inputGeometries", ")", ";", "SimpleGeometryCursor", "intersectorCursor", "=", "new", "SimpleGeometryCursor", "(", "geometry", ")", ";", "GeometryCursor", "result", "=", "op", ".", "execute", "(", "inputGeometriesCursor", ",", "intersectorCursor", ",", "spatialReference", ",", "null", ")", ";", "ArrayList", "<", "Geometry", ">", "resultGeoms", "=", "new", "ArrayList", "<", "Geometry", ">", "(", ")", ";", "Geometry", "g", ";", "while", "(", "(", "g", "=", "result", ".", "next", "(", ")", ")", "!=", "null", ")", "{", "resultGeoms", ".", "add", "(", "g", ")", ";", "}", "Geometry", "[", "]", "resultarr", "=", "resultGeoms", ".", "toArray", "(", "new", "Geometry", "[", "0", "]", ")", ";", "return", "resultarr", ";", "}"], "docstring": "Constructs the set-theoretic intersection between an array of geometries\nand another geometry.\n\nSee OperatorIntersection (also for dimension specific intersection).\n\n@param inputGeometries\nAn array of geometry objects.\n@param geometry\nThe geometry object.\n@return Any array of geometry objects showing the intersection.", "docstring_tokens": ["Constructs", "the", "set", "-", "theoretic", "intersection", "between", "an", "array", "of", "geometries", "and", "another", "geometry", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/GeometryEngine.java#L393-L412", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/GeometryEngine.java", "func_name": "GeometryEngine.cut", "original_string": "public static Geometry[] cut(Geometry cuttee, Polyline cutter,\n\t\t\tSpatialReference spatialReference) {\n\t\tif (cuttee == null || cutter == null)\n\t\t\treturn null;\n\n\t\tOperatorCut op = (OperatorCut) factory.getOperator(Operator.Type.Cut);\n\t\tGeometryCursor cursor = op.execute(true, cuttee, cutter,\n\t\t\t\tspatialReference, null);\n\t\tArrayList<Geometry> cutsList = new ArrayList<Geometry>();\n\n\t\tGeometry geometry;\n\t\twhile ((geometry = cursor.next()) != null) {\n\t\t\tif (!geometry.isEmpty()) {\n\t\t\t\tcutsList.add(geometry);\n\t\t\t}\n\t\t}\n\n\t\treturn cutsList.toArray(new Geometry[0]);\n\t}", "language": "java", "code": "public static Geometry[] cut(Geometry cuttee, Polyline cutter,\n\t\t\tSpatialReference spatialReference) {\n\t\tif (cuttee == null || cutter == null)\n\t\t\treturn null;\n\n\t\tOperatorCut op = (OperatorCut) factory.getOperator(Operator.Type.Cut);\n\t\tGeometryCursor cursor = op.execute(true, cuttee, cutter,\n\t\t\t\tspatialReference, null);\n\t\tArrayList<Geometry> cutsList = new ArrayList<Geometry>();\n\n\t\tGeometry geometry;\n\t\twhile ((geometry = cursor.next()) != null) {\n\t\t\tif (!geometry.isEmpty()) {\n\t\t\t\tcutsList.add(geometry);\n\t\t\t}\n\t\t}\n\n\t\treturn cutsList.toArray(new Geometry[0]);\n\t}", "code_tokens": ["public", "static", "Geometry", "[", "]", "cut", "(", "Geometry", "cuttee", ",", "Polyline", "cutter", ",", "SpatialReference", "spatialReference", ")", "{", "if", "(", "cuttee", "==", "null", "||", "cutter", "==", "null", ")", "return", "null", ";", "OperatorCut", "op", "=", "(", "OperatorCut", ")", "factory", ".", "getOperator", "(", "Operator", ".", "Type", ".", "Cut", ")", ";", "GeometryCursor", "cursor", "=", "op", ".", "execute", "(", "true", ",", "cuttee", ",", "cutter", ",", "spatialReference", ",", "null", ")", ";", "ArrayList", "<", "Geometry", ">", "cutsList", "=", "new", "ArrayList", "<", "Geometry", ">", "(", ")", ";", "Geometry", "geometry", ";", "while", "(", "(", "geometry", "=", "cursor", ".", "next", "(", ")", ")", "!=", "null", ")", "{", "if", "(", "!", "geometry", ".", "isEmpty", "(", ")", ")", "{", "cutsList", ".", "add", "(", "geometry", ")", ";", "}", "}", "return", "cutsList", ".", "toArray", "(", "new", "Geometry", "[", "0", "]", ")", ";", "}"], "docstring": "Calculates the cut geometry from a target geometry using a polyline. For\nPolylines, all left cuts will be grouped together in the first Geometry,\nRight cuts and coincident cuts are grouped in the second Geometry, and\neach undefined cut, along with any uncut parts, are output as separate\nPolylines. For Polygons, all left cuts are grouped in the first Polygon,\nall right cuts are in the second Polygon, and each undefined cut, along\nwith any left-over parts after cutting, are output as a separate Polygon.\nIf there were no cuts then the array will be empty. An undefined cut will\nonly be produced if a left cut or right cut was produced, and there was a\npart left over after cutting or a cut is bounded to the left and right of\nthe cutter.\n\nSee OperatorCut.\n\n@param cuttee\nThe geometry to be cut.\n@param cutter\nThe polyline to cut the geometry.\n@param spatialReference\nThe spatial reference of the geometries.\n@return An array of geometries created from cutting.", "docstring_tokens": ["Calculates", "the", "cut", "geometry", "from", "a", "target", "geometry", "using", "a", "polyline", ".", "For", "Polylines", "all", "left", "cuts", "will", "be", "grouped", "together", "in", "the", "first", "Geometry", "Right", "cuts", "and", "coincident", "cuts", "are", "grouped", "in", "the", "second", "Geometry", "and", "each", "undefined", "cut", "along", "with", "any", "uncut", "parts", "are", "output", "as", "separate", "Polylines", ".", "For", "Polygons", "all", "left", "cuts", "are", "grouped", "in", "the", "first", "Polygon", "all", "right", "cuts", "are", "in", "the", "second", "Polygon", "and", "each", "undefined", "cut", "along", "with", "any", "left", "-", "over", "parts", "after", "cutting", "are", "output", "as", "a", "separate", "Polygon", ".", "If", "there", "were", "no", "cuts", "then", "the", "array", "will", "be", "empty", ".", "An", "undefined", "cut", "will", "only", "be", "produced", "if", "a", "left", "cut", "or", "right", "cut", "was", "produced", "and", "there", "was", "a", "part", "left", "over", "after", "cutting", "or", "a", "cut", "is", "bounded", "to", "the", "left", "and", "right", "of", "the", "cutter", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/GeometryEngine.java#L642-L660", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java", "func_name": "RelationalOperationsMatrix.multiPointRelateMultiPoint_", "original_string": "static boolean multiPointRelateMultiPoint_(MultiPoint multipoint_a,\n\t\t\tMultiPoint multipoint_b, double tolerance, String scl,\n\t\t\tProgressTracker progress_tracker) {\n\t\tRelationalOperationsMatrix relOps = new RelationalOperationsMatrix();\n\t\trelOps.resetMatrix_();\n\t\trelOps.setPredicates_(scl);\n\t\trelOps.setPointPointPredicates_();\n\n\t\tEnvelope2D env_a = new Envelope2D(), env_b = new Envelope2D();\n\t\tmultipoint_a.queryEnvelope2D(env_a);\n\t\tmultipoint_b.queryEnvelope2D(env_b);\n\n\t\tboolean bRelationKnown = false;\n\t\tboolean b_disjoint = RelationalOperations.envelopeDisjointEnvelope_(\n\t\t\t\tenv_a, env_b, tolerance, progress_tracker);\n\n\t\tif (b_disjoint) {\n\t\t\trelOps.pointPointDisjointPredicates_();\n\t\t\tbRelationKnown = true;\n\t\t}\n\n\t\tif (!bRelationKnown) {\n\t\t\tEditShape edit_shape = new EditShape();\n\t\t\tint geom_a = edit_shape.addGeometry(multipoint_a);\n\t\t\tint geom_b = edit_shape.addGeometry(multipoint_b);\n\t\t\trelOps.setEditShapeCrackAndCluster_(edit_shape, tolerance,\n\t\t\t\t\tprogress_tracker);\n\t\t\trelOps.computeMatrixTopoGraphClusters_(geom_a, geom_b);\n\t\t\trelOps.m_topo_graph.removeShape();\n\t\t}\n\n\t\tboolean bRelation = relationCompare_(relOps.m_matrix, relOps.m_scl);\n\t\treturn bRelation;\n\t}", "language": "java", "code": "static boolean multiPointRelateMultiPoint_(MultiPoint multipoint_a,\n\t\t\tMultiPoint multipoint_b, double tolerance, String scl,\n\t\t\tProgressTracker progress_tracker) {\n\t\tRelationalOperationsMatrix relOps = new RelationalOperationsMatrix();\n\t\trelOps.resetMatrix_();\n\t\trelOps.setPredicates_(scl);\n\t\trelOps.setPointPointPredicates_();\n\n\t\tEnvelope2D env_a = new Envelope2D(), env_b = new Envelope2D();\n\t\tmultipoint_a.queryEnvelope2D(env_a);\n\t\tmultipoint_b.queryEnvelope2D(env_b);\n\n\t\tboolean bRelationKnown = false;\n\t\tboolean b_disjoint = RelationalOperations.envelopeDisjointEnvelope_(\n\t\t\t\tenv_a, env_b, tolerance, progress_tracker);\n\n\t\tif (b_disjoint) {\n\t\t\trelOps.pointPointDisjointPredicates_();\n\t\t\tbRelationKnown = true;\n\t\t}\n\n\t\tif (!bRelationKnown) {\n\t\t\tEditShape edit_shape = new EditShape();\n\t\t\tint geom_a = edit_shape.addGeometry(multipoint_a);\n\t\t\tint geom_b = edit_shape.addGeometry(multipoint_b);\n\t\t\trelOps.setEditShapeCrackAndCluster_(edit_shape, tolerance,\n\t\t\t\t\tprogress_tracker);\n\t\t\trelOps.computeMatrixTopoGraphClusters_(geom_a, geom_b);\n\t\t\trelOps.m_topo_graph.removeShape();\n\t\t}\n\n\t\tboolean bRelation = relationCompare_(relOps.m_matrix, relOps.m_scl);\n\t\treturn bRelation;\n\t}", "code_tokens": ["static", "boolean", "multiPointRelateMultiPoint_", "(", "MultiPoint", "multipoint_a", ",", "MultiPoint", "multipoint_b", ",", "double", "tolerance", ",", "String", "scl", ",", "ProgressTracker", "progress_tracker", ")", "{", "RelationalOperationsMatrix", "relOps", "=", "new", "RelationalOperationsMatrix", "(", ")", ";", "relOps", ".", "resetMatrix_", "(", ")", ";", "relOps", ".", "setPredicates_", "(", "scl", ")", ";", "relOps", ".", "setPointPointPredicates_", "(", ")", ";", "Envelope2D", "env_a", "=", "new", "Envelope2D", "(", ")", ",", "env_b", "=", "new", "Envelope2D", "(", ")", ";", "multipoint_a", ".", "queryEnvelope2D", "(", "env_a", ")", ";", "multipoint_b", ".", "queryEnvelope2D", "(", "env_b", ")", ";", "boolean", "bRelationKnown", "=", "false", ";", "boolean", "b_disjoint", "=", "RelationalOperations", ".", "envelopeDisjointEnvelope_", "(", "env_a", ",", "env_b", ",", "tolerance", ",", "progress_tracker", ")", ";", "if", "(", "b_disjoint", ")", "{", "relOps", ".", "pointPointDisjointPredicates_", "(", ")", ";", "bRelationKnown", "=", "true", ";", "}", "if", "(", "!", "bRelationKnown", ")", "{", "EditShape", "edit_shape", "=", "new", "EditShape", "(", ")", ";", "int", "geom_a", "=", "edit_shape", ".", "addGeometry", "(", "multipoint_a", ")", ";", "int", "geom_b", "=", "edit_shape", ".", "addGeometry", "(", "multipoint_b", ")", ";", "relOps", ".", "setEditShapeCrackAndCluster_", "(", "edit_shape", ",", "tolerance", ",", "progress_tracker", ")", ";", "relOps", ".", "computeMatrixTopoGraphClusters_", "(", "geom_a", ",", "geom_b", ")", ";", "relOps", ".", "m_topo_graph", ".", "removeShape", "(", ")", ";", "}", "boolean", "bRelation", "=", "relationCompare_", "(", "relOps", ".", "m_matrix", ",", "relOps", ".", "m_scl", ")", ";", "return", "bRelation", ";", "}"], "docstring": "Returns true if the relation holds.", "docstring_tokens": ["Returns", "true", "if", "the", "relation", "holds", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java#L695-L728", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java", "func_name": "RelationalOperationsMatrix.getPredefinedRelation_", "original_string": "private static int getPredefinedRelation_(String scl, int dim_a, int dim_b) {\n\t\tif (equals_(scl))\n\t\t\treturn RelationalOperations.Relation.equals;\n\n\t\tif (disjoint_(scl))\n\t\t\treturn RelationalOperations.Relation.disjoint;\n\n\t\tif (touches_(scl, dim_a, dim_b))\n\t\t\treturn RelationalOperations.Relation.touches;\n\n\t\tif (crosses_(scl, dim_a, dim_b))\n\t\t\treturn RelationalOperations.Relation.crosses;\n\n\t\tif (contains_(scl))\n\t\t\treturn RelationalOperations.Relation.contains;\n\n\t\tif (overlaps_(scl, dim_a, dim_b))\n\t\t\treturn RelationalOperations.Relation.overlaps;\n\n\t\treturn RelationalOperations.Relation.unknown;\n\t}", "language": "java", "code": "private static int getPredefinedRelation_(String scl, int dim_a, int dim_b) {\n\t\tif (equals_(scl))\n\t\t\treturn RelationalOperations.Relation.equals;\n\n\t\tif (disjoint_(scl))\n\t\t\treturn RelationalOperations.Relation.disjoint;\n\n\t\tif (touches_(scl, dim_a, dim_b))\n\t\t\treturn RelationalOperations.Relation.touches;\n\n\t\tif (crosses_(scl, dim_a, dim_b))\n\t\t\treturn RelationalOperations.Relation.crosses;\n\n\t\tif (contains_(scl))\n\t\t\treturn RelationalOperations.Relation.contains;\n\n\t\tif (overlaps_(scl, dim_a, dim_b))\n\t\t\treturn RelationalOperations.Relation.overlaps;\n\n\t\treturn RelationalOperations.Relation.unknown;\n\t}", "code_tokens": ["private", "static", "int", "getPredefinedRelation_", "(", "String", "scl", ",", "int", "dim_a", ",", "int", "dim_b", ")", "{", "if", "(", "equals_", "(", "scl", ")", ")", "return", "RelationalOperations", ".", "Relation", ".", "equals", ";", "if", "(", "disjoint_", "(", "scl", ")", ")", "return", "RelationalOperations", ".", "Relation", ".", "disjoint", ";", "if", "(", "touches_", "(", "scl", ",", "dim_a", ",", "dim_b", ")", ")", "return", "RelationalOperations", ".", "Relation", ".", "touches", ";", "if", "(", "crosses_", "(", "scl", ",", "dim_a", ",", "dim_b", ")", ")", "return", "RelationalOperations", ".", "Relation", ".", "crosses", ";", "if", "(", "contains_", "(", "scl", ")", ")", "return", "RelationalOperations", ".", "Relation", ".", "contains", ";", "if", "(", "overlaps_", "(", "scl", ",", "dim_a", ",", "dim_b", ")", ")", "return", "RelationalOperations", ".", "Relation", ".", "overlaps", ";", "return", "RelationalOperations", ".", "Relation", ".", "unknown", ";", "}"], "docstring": "Checks whether scl string is a predefined relation.", "docstring_tokens": ["Checks", "whether", "scl", "string", "is", "a", "predefined", "relation", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java#L1122-L1142", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java", "func_name": "RelationalOperationsMatrix.equals_", "original_string": "private static boolean equals_(String scl) {\n\t\t// Valid for all\n\t\tif (scl.charAt(0) == 'T' && scl.charAt(1) == '*'\n\t\t\t\t&& scl.charAt(2) == 'F' && scl.charAt(3) == '*'\n\t\t\t\t&& scl.charAt(4) == '*' && scl.charAt(5) == 'F'\n\t\t\t\t&& scl.charAt(6) == 'F' && scl.charAt(7) == 'F'\n\t\t\t\t&& scl.charAt(8) == '*')\n\t\t\treturn true;\n\n\t\treturn false;\n\t}", "language": "java", "code": "private static boolean equals_(String scl) {\n\t\t// Valid for all\n\t\tif (scl.charAt(0) == 'T' && scl.charAt(1) == '*'\n\t\t\t\t&& scl.charAt(2) == 'F' && scl.charAt(3) == '*'\n\t\t\t\t&& scl.charAt(4) == '*' && scl.charAt(5) == 'F'\n\t\t\t\t&& scl.charAt(6) == 'F' && scl.charAt(7) == 'F'\n\t\t\t\t&& scl.charAt(8) == '*')\n\t\t\treturn true;\n\n\t\treturn false;\n\t}", "code_tokens": ["private", "static", "boolean", "equals_", "(", "String", "scl", ")", "{", "// Valid for all", "if", "(", "scl", ".", "charAt", "(", "0", ")", "==", "'", "'", "&&", "scl", ".", "charAt", "(", "1", ")", "==", "'", "'", "&&", "scl", ".", "charAt", "(", "2", ")", "==", "'", "'", "&&", "scl", ".", "charAt", "(", "3", ")", "==", "'", "'", "&&", "scl", ".", "charAt", "(", "4", ")", "==", "'", "'", "&&", "scl", ".", "charAt", "(", "5", ")", "==", "'", "'", "&&", "scl", ".", "charAt", "(", "6", ")", "==", "'", "'", "&&", "scl", ".", "charAt", "(", "7", ")", "==", "'", "'", "&&", "scl", ".", "charAt", "(", "8", ")", "==", "'", "'", ")", "return", "true", ";", "return", "false", ";", "}"], "docstring": "Checks whether the scl string is the equals relation.", "docstring_tokens": ["Checks", "whether", "the", "scl", "string", "is", "the", "equals", "relation", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java#L1145-L1155", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java", "func_name": "RelationalOperationsMatrix.areaPointPredicates_", "original_string": "private boolean areaPointPredicates_(int cluster, int id_a, int id_b) {\n        boolean bRelationKnown = true;\n\n        if (m_perform_predicates[MatrixPredicate.InteriorInterior])\n        {\n            interiorAreaInteriorPoint_(cluster, id_a);\n            bRelationKnown &= isPredicateKnown_(MatrixPredicate.InteriorInterior);\n        }\n\n        if (m_perform_predicates[MatrixPredicate.InteriorExterior])\n        {\n            interiorAreaExteriorPoint_(cluster, id_a);\n            bRelationKnown &= isPredicateKnown_(MatrixPredicate.InteriorExterior);\n        }\n\n        if (m_perform_predicates[MatrixPredicate.BoundaryInterior])\n        {\n            boundaryAreaInteriorPoint_(cluster, id_a, id_b);\n            bRelationKnown &= isPredicateKnown_(MatrixPredicate.BoundaryInterior);\n        }\n\n        if (m_perform_predicates[MatrixPredicate.BoundaryExterior])\n        {\n            boundaryAreaExteriorPoint_(cluster, id_a);\n            bRelationKnown &= isPredicateKnown_(MatrixPredicate.BoundaryExterior);\n        }\n\n        if (m_perform_predicates[MatrixPredicate.ExteriorInterior])\n        {\n            exteriorAreaInteriorPoint_(cluster, id_a);\n            bRelationKnown &= isPredicateKnown_(MatrixPredicate.ExteriorInterior);\n        }\n\n        return bRelationKnown;\n\t}", "language": "java", "code": "private boolean areaPointPredicates_(int cluster, int id_a, int id_b) {\n        boolean bRelationKnown = true;\n\n        if (m_perform_predicates[MatrixPredicate.InteriorInterior])\n        {\n            interiorAreaInteriorPoint_(cluster, id_a);\n            bRelationKnown &= isPredicateKnown_(MatrixPredicate.InteriorInterior);\n        }\n\n        if (m_perform_predicates[MatrixPredicate.InteriorExterior])\n        {\n            interiorAreaExteriorPoint_(cluster, id_a);\n            bRelationKnown &= isPredicateKnown_(MatrixPredicate.InteriorExterior);\n        }\n\n        if (m_perform_predicates[MatrixPredicate.BoundaryInterior])\n        {\n            boundaryAreaInteriorPoint_(cluster, id_a, id_b);\n            bRelationKnown &= isPredicateKnown_(MatrixPredicate.BoundaryInterior);\n        }\n\n        if (m_perform_predicates[MatrixPredicate.BoundaryExterior])\n        {\n            boundaryAreaExteriorPoint_(cluster, id_a);\n            bRelationKnown &= isPredicateKnown_(MatrixPredicate.BoundaryExterior);\n        }\n\n        if (m_perform_predicates[MatrixPredicate.ExteriorInterior])\n        {\n            exteriorAreaInteriorPoint_(cluster, id_a);\n            bRelationKnown &= isPredicateKnown_(MatrixPredicate.ExteriorInterior);\n        }\n\n        return bRelationKnown;\n\t}", "code_tokens": ["private", "boolean", "areaPointPredicates_", "(", "int", "cluster", ",", "int", "id_a", ",", "int", "id_b", ")", "{", "boolean", "bRelationKnown", "=", "true", ";", "if", "(", "m_perform_predicates", "[", "MatrixPredicate", ".", "InteriorInterior", "]", ")", "{", "interiorAreaInteriorPoint_", "(", "cluster", ",", "id_a", ")", ";", "bRelationKnown", "&=", "isPredicateKnown_", "(", "MatrixPredicate", ".", "InteriorInterior", ")", ";", "}", "if", "(", "m_perform_predicates", "[", "MatrixPredicate", ".", "InteriorExterior", "]", ")", "{", "interiorAreaExteriorPoint_", "(", "cluster", ",", "id_a", ")", ";", "bRelationKnown", "&=", "isPredicateKnown_", "(", "MatrixPredicate", ".", "InteriorExterior", ")", ";", "}", "if", "(", "m_perform_predicates", "[", "MatrixPredicate", ".", "BoundaryInterior", "]", ")", "{", "boundaryAreaInteriorPoint_", "(", "cluster", ",", "id_a", ",", "id_b", ")", ";", "bRelationKnown", "&=", "isPredicateKnown_", "(", "MatrixPredicate", ".", "BoundaryInterior", ")", ";", "}", "if", "(", "m_perform_predicates", "[", "MatrixPredicate", ".", "BoundaryExterior", "]", ")", "{", "boundaryAreaExteriorPoint_", "(", "cluster", ",", "id_a", ")", ";", "bRelationKnown", "&=", "isPredicateKnown_", "(", "MatrixPredicate", ".", "BoundaryExterior", ")", ";", "}", "if", "(", "m_perform_predicates", "[", "MatrixPredicate", ".", "ExteriorInterior", "]", ")", "{", "exteriorAreaInteriorPoint_", "(", "cluster", ",", "id_a", ")", ";", "bRelationKnown", "&=", "isPredicateKnown_", "(", "MatrixPredicate", ".", "ExteriorInterior", ")", ";", "}", "return", "bRelationKnown", ";", "}"], "docstring": "Invokes the 9 relational predicates of area vs Point.", "docstring_tokens": ["Invokes", "the", "9", "relational", "predicates", "of", "area", "vs", "Point", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java#L1981-L2015", "partition": "train"}
