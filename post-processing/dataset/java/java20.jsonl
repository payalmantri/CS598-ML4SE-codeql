{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java", "func_name": "RelationalOperationsMatrix.setPredicates_", "original_string": "private void setPredicates_(String scl) {\n\t\tm_scl = scl;\n\n\t\tfor (int i = 0; i < 9; i++) {\n\t\t\tif (m_scl.charAt(i) != '*') {\n\t\t\t\tm_perform_predicates[i] = true;\n\t\t\t\tm_predicate_count++;\n\t\t\t} else\n\t\t\t\tm_perform_predicates[i] = false;\n\t\t}\n\t}", "language": "java", "code": "private void setPredicates_(String scl) {\n\t\tm_scl = scl;\n\n\t\tfor (int i = 0; i < 9; i++) {\n\t\t\tif (m_scl.charAt(i) != '*') {\n\t\t\t\tm_perform_predicates[i] = true;\n\t\t\t\tm_predicate_count++;\n\t\t\t} else\n\t\t\t\tm_perform_predicates[i] = false;\n\t\t}\n\t}", "code_tokens": ["private", "void", "setPredicates_", "(", "String", "scl", ")", "{", "m_scl", "=", "scl", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "9", ";", "i", "++", ")", "{", "if", "(", "m_scl", ".", "charAt", "(", "i", ")", "!=", "'", "'", ")", "{", "m_perform_predicates", "[", "i", "]", "=", "true", ";", "m_predicate_count", "++", ";", "}", "else", "m_perform_predicates", "[", "i", "]", "=", "false", ";", "}", "}"], "docstring": "Sets the relation predicates from the scl string.", "docstring_tokens": ["Sets", "the", "relation", "predicates", "from", "the", "scl", "string", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java#L1360-L1370", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/ConvexHull.java", "func_name": "ConvexHull.getBoundingGeometry", "original_string": "Geometry getBoundingGeometry() {\n\t\t// Extracts the convex hull from the tree. Reading the tree in order from first to last is the resulting convex hull.\n\t\tPoint point = new Point();\n\t\tint first = m_tree_hull.getFirst(-1);\n\t\tPolygon hull = new Polygon(m_shape.getVertexDescription());\n\t\tif (m_tree_hull.size(-1) == 0)\n\t\t\treturn hull;\n\t\t\n\t\tm_shape.queryPoint(m_tree_hull.getElement(first), point);\n\t\thull.startPath(point);\n\n\t\tfor (int i = m_tree_hull.getNext(first); i != -1; i = m_tree_hull.getNext(i)) {\n\t\t\tm_shape.queryPoint(m_tree_hull.getElement(i), point);\n\t\t\thull.lineTo(point);\n\t\t}\n\n\t\treturn hull;\n\t}", "language": "java", "code": "Geometry getBoundingGeometry() {\n\t\t// Extracts the convex hull from the tree. Reading the tree in order from first to last is the resulting convex hull.\n\t\tPoint point = new Point();\n\t\tint first = m_tree_hull.getFirst(-1);\n\t\tPolygon hull = new Polygon(m_shape.getVertexDescription());\n\t\tif (m_tree_hull.size(-1) == 0)\n\t\t\treturn hull;\n\t\t\n\t\tm_shape.queryPoint(m_tree_hull.getElement(first), point);\n\t\thull.startPath(point);\n\n\t\tfor (int i = m_tree_hull.getNext(first); i != -1; i = m_tree_hull.getNext(i)) {\n\t\t\tm_shape.queryPoint(m_tree_hull.getElement(i), point);\n\t\t\thull.lineTo(point);\n\t\t}\n\n\t\treturn hull;\n\t}", "code_tokens": ["Geometry", "getBoundingGeometry", "(", ")", "{", "// Extracts the convex hull from the tree. Reading the tree in order from first to last is the resulting convex hull.", "Point", "point", "=", "new", "Point", "(", ")", ";", "int", "first", "=", "m_tree_hull", ".", "getFirst", "(", "-", "1", ")", ";", "Polygon", "hull", "=", "new", "Polygon", "(", "m_shape", ".", "getVertexDescription", "(", ")", ")", ";", "if", "(", "m_tree_hull", ".", "size", "(", "-", "1", ")", "==", "0", ")", "return", "hull", ";", "m_shape", ".", "queryPoint", "(", "m_tree_hull", ".", "getElement", "(", "first", ")", ",", "point", ")", ";", "hull", ".", "startPath", "(", "point", ")", ";", "for", "(", "int", "i", "=", "m_tree_hull", ".", "getNext", "(", "first", ")", ";", "i", "!=", "-", "1", ";", "i", "=", "m_tree_hull", ".", "getNext", "(", "i", ")", ")", "{", "m_shape", ".", "queryPoint", "(", "m_tree_hull", ".", "getElement", "(", "i", ")", ",", "point", ")", ";", "hull", ".", "lineTo", "(", "point", ")", ";", "}", "return", "hull", ";", "}"], "docstring": "Gets the current bounding geometry.\nReturns a Geometry.", "docstring_tokens": ["Gets", "the", "current", "bounding", "geometry", ".", "Returns", "a", "Geometry", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/ConvexHull.java#L81-L98", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/EditShape.java", "func_name": "EditShape.getEnvelope2D", "original_string": "Envelope2D getEnvelope2D() {\n\t\tEnvelope2D env = new Envelope2D();\n\t\tenv.setEmpty();\n\t\tVertexIterator vert_iter = queryVertexIterator();\n\t\tPoint2D pt = new Point2D();\n\t\tboolean b_first = true;\n\t\tfor (int ivertex = vert_iter.next(); ivertex != -1; ivertex = vert_iter\n\t\t\t\t.next()) {\n\t\t\tgetXY(ivertex, pt);\n\t\t\tif (b_first)\n\t\t\t\tenv.merge(pt.x, pt.y);\n\t\t\telse\n\t\t\t\tenv.mergeNE(pt.x, pt.y);\n\n\t\t\tb_first = false;\n\t\t}\n\n\t\treturn env;\n\t}", "language": "java", "code": "Envelope2D getEnvelope2D() {\n\t\tEnvelope2D env = new Envelope2D();\n\t\tenv.setEmpty();\n\t\tVertexIterator vert_iter = queryVertexIterator();\n\t\tPoint2D pt = new Point2D();\n\t\tboolean b_first = true;\n\t\tfor (int ivertex = vert_iter.next(); ivertex != -1; ivertex = vert_iter\n\t\t\t\t.next()) {\n\t\t\tgetXY(ivertex, pt);\n\t\t\tif (b_first)\n\t\t\t\tenv.merge(pt.x, pt.y);\n\t\t\telse\n\t\t\t\tenv.mergeNE(pt.x, pt.y);\n\n\t\t\tb_first = false;\n\t\t}\n\n\t\treturn env;\n\t}", "code_tokens": ["Envelope2D", "getEnvelope2D", "(", ")", "{", "Envelope2D", "env", "=", "new", "Envelope2D", "(", ")", ";", "env", ".", "setEmpty", "(", ")", ";", "VertexIterator", "vert_iter", "=", "queryVertexIterator", "(", ")", ";", "Point2D", "pt", "=", "new", "Point2D", "(", ")", ";", "boolean", "b_first", "=", "true", ";", "for", "(", "int", "ivertex", "=", "vert_iter", ".", "next", "(", ")", ";", "ivertex", "!=", "-", "1", ";", "ivertex", "=", "vert_iter", ".", "next", "(", ")", ")", "{", "getXY", "(", "ivertex", ",", "pt", ")", ";", "if", "(", "b_first", ")", "env", ".", "merge", "(", "pt", ".", "x", ",", "pt", ".", "y", ")", ";", "else", "env", ".", "mergeNE", "(", "pt", ".", "x", ",", "pt", ".", "y", ")", ";", "b_first", "=", "false", ";", "}", "return", "env", ";", "}"], "docstring": "Returns envelope of all coordinates.", "docstring_tokens": ["Returns", "envelope", "of", "all", "coordinates", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/EditShape.java#L549-L567", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/JsonParserReader.java", "func_name": "JsonParserReader.createFromStringNNT", "original_string": "public static JsonReader createFromStringNNT(String str) {\n\t\ttry {\n\t\t\tJsonFactory factory = new JsonFactory();\n\t\t\tJsonParser jsonParser = factory.createParser(str);\n\t\n\t\t\treturn new JsonParserReader(jsonParser);\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tthrow new JsonGeometryException(ex.getMessage());\n\t\t}\n\t}", "language": "java", "code": "public static JsonReader createFromStringNNT(String str) {\n\t\ttry {\n\t\t\tJsonFactory factory = new JsonFactory();\n\t\t\tJsonParser jsonParser = factory.createParser(str);\n\t\n\t\t\treturn new JsonParserReader(jsonParser);\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tthrow new JsonGeometryException(ex.getMessage());\n\t\t}\n\t}", "code_tokens": ["public", "static", "JsonReader", "createFromStringNNT", "(", "String", "str", ")", "{", "try", "{", "JsonFactory", "factory", "=", "new", "JsonFactory", "(", ")", ";", "JsonParser", "jsonParser", "=", "factory", ".", "createParser", "(", "str", ")", ";", "return", "new", "JsonParserReader", "(", "jsonParser", ")", ";", "}", "catch", "(", "Exception", "ex", ")", "{", "throw", "new", "JsonGeometryException", "(", "ex", ".", "getMessage", "(", ")", ")", ";", "}", "}"], "docstring": "Creates a JsonReader for the string.\nThe nextToken is not called by this method.", "docstring_tokens": ["Creates", "a", "JsonReader", "for", "the", "string", ".", "The", "nextToken", "is", "not", "called", "by", "this", "method", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/JsonParserReader.java#L62-L72", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/GeometryEngine.java", "func_name": "GeometryEngine.intersect", "original_string": "static Geometry[] intersect(Geometry[] inputGeometries, Geometry geometry,\n\t\t\tSpatialReference spatialReference) {\n\t\tOperatorIntersection op = (OperatorIntersection) factory\n\t\t\t\t.getOperator(Operator.Type.Intersection);\n\t\tSimpleGeometryCursor inputGeometriesCursor = new SimpleGeometryCursor(\n\t\t\t\tinputGeometries);\n\t\tSimpleGeometryCursor intersectorCursor = new SimpleGeometryCursor(\n\t\t\t\tgeometry);\n\t\tGeometryCursor result = op.execute(inputGeometriesCursor,\n\t\t\t\tintersectorCursor, spatialReference, null);\n\n\t\tArrayList<Geometry> resultGeoms = new ArrayList<Geometry>();\n\t\tGeometry g;\n\t\twhile ((g = result.next()) != null) {\n\t\t\tresultGeoms.add(g);\n\t\t}\n\n\t\tGeometry[] resultarr = resultGeoms.toArray(new Geometry[0]);\n\t\treturn resultarr;\n\t}", "language": "java", "code": "static Geometry[] intersect(Geometry[] inputGeometries, Geometry geometry,\n\t\t\tSpatialReference spatialReference) {\n\t\tOperatorIntersection op = (OperatorIntersection) factory\n\t\t\t\t.getOperator(Operator.Type.Intersection);\n\t\tSimpleGeometryCursor inputGeometriesCursor = new SimpleGeometryCursor(\n\t\t\t\tinputGeometries);\n\t\tSimpleGeometryCursor intersectorCursor = new SimpleGeometryCursor(\n\t\t\t\tgeometry);\n\t\tGeometryCursor result = op.execute(inputGeometriesCursor,\n\t\t\t\tintersectorCursor, spatialReference, null);\n\n\t\tArrayList<Geometry> resultGeoms = new ArrayList<Geometry>();\n\t\tGeometry g;\n\t\twhile ((g = result.next()) != null) {\n\t\t\tresultGeoms.add(g);\n\t\t}\n\n\t\tGeometry[] resultarr = resultGeoms.toArray(new Geometry[0]);\n\t\treturn resultarr;\n\t}", "code_tokens": ["static", "Geometry", "[", "]", "intersect", "(", "Geometry", "[", "]", "inputGeometries", ",", "Geometry", "geometry", ",", "SpatialReference", "spatialReference", ")", "{", "OperatorIntersection", "op", "=", "(", "OperatorIntersection", ")", "factory", ".", "getOperator", "(", "Operator", ".", "Type", ".", "Intersection", ")", ";", "SimpleGeometryCursor", "inputGeometriesCursor", "=", "new", "SimpleGeometryCursor", "(", "inputGeometries", ")", ";", "SimpleGeometryCursor", "intersectorCursor", "=", "new", "SimpleGeometryCursor", "(", "geometry", ")", ";", "GeometryCursor", "result", "=", "op", ".", "execute", "(", "inputGeometriesCursor", ",", "intersectorCursor", ",", "spatialReference", ",", "null", ")", ";", "ArrayList", "<", "Geometry", ">", "resultGeoms", "=", "new", "ArrayList", "<", "Geometry", ">", "(", ")", ";", "Geometry", "g", ";", "while", "(", "(", "g", "=", "result", ".", "next", "(", ")", ")", "!=", "null", ")", "{", "resultGeoms", ".", "add", "(", "g", ")", ";", "}", "Geometry", "[", "]", "resultarr", "=", "resultGeoms", ".", "toArray", "(", "new", "Geometry", "[", "0", "]", ")", ";", "return", "resultarr", ";", "}"], "docstring": "Constructs the set-theoretic intersection between an array of geometries\nand another geometry.\n\nSee OperatorIntersection (also for dimension specific intersection).\n\n@param inputGeometries\nAn array of geometry objects.\n@param geometry\nThe geometry object.\n@return Any array of geometry objects showing the intersection.", "docstring_tokens": ["Constructs", "the", "set", "-", "theoretic", "intersection", "between", "an", "array", "of", "geometries", "and", "another", "geometry", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/GeometryEngine.java#L393-L412", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/GeometryEngine.java", "func_name": "GeometryEngine.cut", "original_string": "public static Geometry[] cut(Geometry cuttee, Polyline cutter,\n\t\t\tSpatialReference spatialReference) {\n\t\tif (cuttee == null || cutter == null)\n\t\t\treturn null;\n\n\t\tOperatorCut op = (OperatorCut) factory.getOperator(Operator.Type.Cut);\n\t\tGeometryCursor cursor = op.execute(true, cuttee, cutter,\n\t\t\t\tspatialReference, null);\n\t\tArrayList<Geometry> cutsList = new ArrayList<Geometry>();\n\n\t\tGeometry geometry;\n\t\twhile ((geometry = cursor.next()) != null) {\n\t\t\tif (!geometry.isEmpty()) {\n\t\t\t\tcutsList.add(geometry);\n\t\t\t}\n\t\t}\n\n\t\treturn cutsList.toArray(new Geometry[0]);\n\t}", "language": "java", "code": "public static Geometry[] cut(Geometry cuttee, Polyline cutter,\n\t\t\tSpatialReference spatialReference) {\n\t\tif (cuttee == null || cutter == null)\n\t\t\treturn null;\n\n\t\tOperatorCut op = (OperatorCut) factory.getOperator(Operator.Type.Cut);\n\t\tGeometryCursor cursor = op.execute(true, cuttee, cutter,\n\t\t\t\tspatialReference, null);\n\t\tArrayList<Geometry> cutsList = new ArrayList<Geometry>();\n\n\t\tGeometry geometry;\n\t\twhile ((geometry = cursor.next()) != null) {\n\t\t\tif (!geometry.isEmpty()) {\n\t\t\t\tcutsList.add(geometry);\n\t\t\t}\n\t\t}\n\n\t\treturn cutsList.toArray(new Geometry[0]);\n\t}", "code_tokens": ["public", "static", "Geometry", "[", "]", "cut", "(", "Geometry", "cuttee", ",", "Polyline", "cutter", ",", "SpatialReference", "spatialReference", ")", "{", "if", "(", "cuttee", "==", "null", "||", "cutter", "==", "null", ")", "return", "null", ";", "OperatorCut", "op", "=", "(", "OperatorCut", ")", "factory", ".", "getOperator", "(", "Operator", ".", "Type", ".", "Cut", ")", ";", "GeometryCursor", "cursor", "=", "op", ".", "execute", "(", "true", ",", "cuttee", ",", "cutter", ",", "spatialReference", ",", "null", ")", ";", "ArrayList", "<", "Geometry", ">", "cutsList", "=", "new", "ArrayList", "<", "Geometry", ">", "(", ")", ";", "Geometry", "geometry", ";", "while", "(", "(", "geometry", "=", "cursor", ".", "next", "(", ")", ")", "!=", "null", ")", "{", "if", "(", "!", "geometry", ".", "isEmpty", "(", ")", ")", "{", "cutsList", ".", "add", "(", "geometry", ")", ";", "}", "}", "return", "cutsList", ".", "toArray", "(", "new", "Geometry", "[", "0", "]", ")", ";", "}"], "docstring": "Calculates the cut geometry from a target geometry using a polyline. For\nPolylines, all left cuts will be grouped together in the first Geometry,\nRight cuts and coincident cuts are grouped in the second Geometry, and\neach undefined cut, along with any uncut parts, are output as separate\nPolylines. For Polygons, all left cuts are grouped in the first Polygon,\nall right cuts are in the second Polygon, and each undefined cut, along\nwith any left-over parts after cutting, are output as a separate Polygon.\nIf there were no cuts then the array will be empty. An undefined cut will\nonly be produced if a left cut or right cut was produced, and there was a\npart left over after cutting or a cut is bounded to the left and right of\nthe cutter.\n\nSee OperatorCut.\n\n@param cuttee\nThe geometry to be cut.\n@param cutter\nThe polyline to cut the geometry.\n@param spatialReference\nThe spatial reference of the geometries.\n@return An array of geometries created from cutting.", "docstring_tokens": ["Calculates", "the", "cut", "geometry", "from", "a", "target", "geometry", "using", "a", "polyline", ".", "For", "Polylines", "all", "left", "cuts", "will", "be", "grouped", "together", "in", "the", "first", "Geometry", "Right", "cuts", "and", "coincident", "cuts", "are", "grouped", "in", "the", "second", "Geometry", "and", "each", "undefined", "cut", "along", "with", "any", "uncut", "parts", "are", "output", "as", "separate", "Polylines", ".", "For", "Polygons", "all", "left", "cuts", "are", "grouped", "in", "the", "first", "Polygon", "all", "right", "cuts", "are", "in", "the", "second", "Polygon", "and", "each", "undefined", "cut", "along", "with", "any", "left", "-", "over", "parts", "after", "cutting", "are", "output", "as", "a", "separate", "Polygon", ".", "If", "there", "were", "no", "cuts", "then", "the", "array", "will", "be", "empty", ".", "An", "undefined", "cut", "will", "only", "be", "produced", "if", "a", "left", "cut", "or", "right", "cut", "was", "produced", "and", "there", "was", "a", "part", "left", "over", "after", "cutting", "or", "a", "cut", "is", "bounded", "to", "the", "left", "and", "right", "of", "the", "cutter", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/GeometryEngine.java#L642-L660", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java", "func_name": "RelationalOperationsMatrix.multiPointRelateMultiPoint_", "original_string": "static boolean multiPointRelateMultiPoint_(MultiPoint multipoint_a,\n\t\t\tMultiPoint multipoint_b, double tolerance, String scl,\n\t\t\tProgressTracker progress_tracker) {\n\t\tRelationalOperationsMatrix relOps = new RelationalOperationsMatrix();\n\t\trelOps.resetMatrix_();\n\t\trelOps.setPredicates_(scl);\n\t\trelOps.setPointPointPredicates_();\n\n\t\tEnvelope2D env_a = new Envelope2D(), env_b = new Envelope2D();\n\t\tmultipoint_a.queryEnvelope2D(env_a);\n\t\tmultipoint_b.queryEnvelope2D(env_b);\n\n\t\tboolean bRelationKnown = false;\n\t\tboolean b_disjoint = RelationalOperations.envelopeDisjointEnvelope_(\n\t\t\t\tenv_a, env_b, tolerance, progress_tracker);\n\n\t\tif (b_disjoint) {\n\t\t\trelOps.pointPointDisjointPredicates_();\n\t\t\tbRelationKnown = true;\n\t\t}\n\n\t\tif (!bRelationKnown) {\n\t\t\tEditShape edit_shape = new EditShape();\n\t\t\tint geom_a = edit_shape.addGeometry(multipoint_a);\n\t\t\tint geom_b = edit_shape.addGeometry(multipoint_b);\n\t\t\trelOps.setEditShapeCrackAndCluster_(edit_shape, tolerance,\n\t\t\t\t\tprogress_tracker);\n\t\t\trelOps.computeMatrixTopoGraphClusters_(geom_a, geom_b);\n\t\t\trelOps.m_topo_graph.removeShape();\n\t\t}\n\n\t\tboolean bRelation = relationCompare_(relOps.m_matrix, relOps.m_scl);\n\t\treturn bRelation;\n\t}", "language": "java", "code": "static boolean multiPointRelateMultiPoint_(MultiPoint multipoint_a,\n\t\t\tMultiPoint multipoint_b, double tolerance, String scl,\n\t\t\tProgressTracker progress_tracker) {\n\t\tRelationalOperationsMatrix relOps = new RelationalOperationsMatrix();\n\t\trelOps.resetMatrix_();\n\t\trelOps.setPredicates_(scl);\n\t\trelOps.setPointPointPredicates_();\n\n\t\tEnvelope2D env_a = new Envelope2D(), env_b = new Envelope2D();\n\t\tmultipoint_a.queryEnvelope2D(env_a);\n\t\tmultipoint_b.queryEnvelope2D(env_b);\n\n\t\tboolean bRelationKnown = false;\n\t\tboolean b_disjoint = RelationalOperations.envelopeDisjointEnvelope_(\n\t\t\t\tenv_a, env_b, tolerance, progress_tracker);\n\n\t\tif (b_disjoint) {\n\t\t\trelOps.pointPointDisjointPredicates_();\n\t\t\tbRelationKnown = true;\n\t\t}\n\n\t\tif (!bRelationKnown) {\n\t\t\tEditShape edit_shape = new EditShape();\n\t\t\tint geom_a = edit_shape.addGeometry(multipoint_a);\n\t\t\tint geom_b = edit_shape.addGeometry(multipoint_b);\n\t\t\trelOps.setEditShapeCrackAndCluster_(edit_shape, tolerance,\n\t\t\t\t\tprogress_tracker);\n\t\t\trelOps.computeMatrixTopoGraphClusters_(geom_a, geom_b);\n\t\t\trelOps.m_topo_graph.removeShape();\n\t\t}\n\n\t\tboolean bRelation = relationCompare_(relOps.m_matrix, relOps.m_scl);\n\t\treturn bRelation;\n\t}", "code_tokens": ["static", "boolean", "multiPointRelateMultiPoint_", "(", "MultiPoint", "multipoint_a", ",", "MultiPoint", "multipoint_b", ",", "double", "tolerance", ",", "String", "scl", ",", "ProgressTracker", "progress_tracker", ")", "{", "RelationalOperationsMatrix", "relOps", "=", "new", "RelationalOperationsMatrix", "(", ")", ";", "relOps", ".", "resetMatrix_", "(", ")", ";", "relOps", ".", "setPredicates_", "(", "scl", ")", ";", "relOps", ".", "setPointPointPredicates_", "(", ")", ";", "Envelope2D", "env_a", "=", "new", "Envelope2D", "(", ")", ",", "env_b", "=", "new", "Envelope2D", "(", ")", ";", "multipoint_a", ".", "queryEnvelope2D", "(", "env_a", ")", ";", "multipoint_b", ".", "queryEnvelope2D", "(", "env_b", ")", ";", "boolean", "bRelationKnown", "=", "false", ";", "boolean", "b_disjoint", "=", "RelationalOperations", ".", "envelopeDisjointEnvelope_", "(", "env_a", ",", "env_b", ",", "tolerance", ",", "progress_tracker", ")", ";", "if", "(", "b_disjoint", ")", "{", "relOps", ".", "pointPointDisjointPredicates_", "(", ")", ";", "bRelationKnown", "=", "true", ";", "}", "if", "(", "!", "bRelationKnown", ")", "{", "EditShape", "edit_shape", "=", "new", "EditShape", "(", ")", ";", "int", "geom_a", "=", "edit_shape", ".", "addGeometry", "(", "multipoint_a", ")", ";", "int", "geom_b", "=", "edit_shape", ".", "addGeometry", "(", "multipoint_b", ")", ";", "relOps", ".", "setEditShapeCrackAndCluster_", "(", "edit_shape", ",", "tolerance", ",", "progress_tracker", ")", ";", "relOps", ".", "computeMatrixTopoGraphClusters_", "(", "geom_a", ",", "geom_b", ")", ";", "relOps", ".", "m_topo_graph", ".", "removeShape", "(", ")", ";", "}", "boolean", "bRelation", "=", "relationCompare_", "(", "relOps", ".", "m_matrix", ",", "relOps", ".", "m_scl", ")", ";", "return", "bRelation", ";", "}"], "docstring": "Returns true if the relation holds.", "docstring_tokens": ["Returns", "true", "if", "the", "relation", "holds", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java#L695-L728", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java", "func_name": "RelationalOperationsMatrix.getPredefinedRelation_", "original_string": "private static int getPredefinedRelation_(String scl, int dim_a, int dim_b) {\n\t\tif (equals_(scl))\n\t\t\treturn RelationalOperations.Relation.equals;\n\n\t\tif (disjoint_(scl))\n\t\t\treturn RelationalOperations.Relation.disjoint;\n\n\t\tif (touches_(scl, dim_a, dim_b))\n\t\t\treturn RelationalOperations.Relation.touches;\n\n\t\tif (crosses_(scl, dim_a, dim_b))\n\t\t\treturn RelationalOperations.Relation.crosses;\n\n\t\tif (contains_(scl))\n\t\t\treturn RelationalOperations.Relation.contains;\n\n\t\tif (overlaps_(scl, dim_a, dim_b))\n\t\t\treturn RelationalOperations.Relation.overlaps;\n\n\t\treturn RelationalOperations.Relation.unknown;\n\t}", "language": "java", "code": "private static int getPredefinedRelation_(String scl, int dim_a, int dim_b) {\n\t\tif (equals_(scl))\n\t\t\treturn RelationalOperations.Relation.equals;\n\n\t\tif (disjoint_(scl))\n\t\t\treturn RelationalOperations.Relation.disjoint;\n\n\t\tif (touches_(scl, dim_a, dim_b))\n\t\t\treturn RelationalOperations.Relation.touches;\n\n\t\tif (crosses_(scl, dim_a, dim_b))\n\t\t\treturn RelationalOperations.Relation.crosses;\n\n\t\tif (contains_(scl))\n\t\t\treturn RelationalOperations.Relation.contains;\n\n\t\tif (overlaps_(scl, dim_a, dim_b))\n\t\t\treturn RelationalOperations.Relation.overlaps;\n\n\t\treturn RelationalOperations.Relation.unknown;\n\t}", "code_tokens": ["private", "static", "int", "getPredefinedRelation_", "(", "String", "scl", ",", "int", "dim_a", ",", "int", "dim_b", ")", "{", "if", "(", "equals_", "(", "scl", ")", ")", "return", "RelationalOperations", ".", "Relation", ".", "equals", ";", "if", "(", "disjoint_", "(", "scl", ")", ")", "return", "RelationalOperations", ".", "Relation", ".", "disjoint", ";", "if", "(", "touches_", "(", "scl", ",", "dim_a", ",", "dim_b", ")", ")", "return", "RelationalOperations", ".", "Relation", ".", "touches", ";", "if", "(", "crosses_", "(", "scl", ",", "dim_a", ",", "dim_b", ")", ")", "return", "RelationalOperations", ".", "Relation", ".", "crosses", ";", "if", "(", "contains_", "(", "scl", ")", ")", "return", "RelationalOperations", ".", "Relation", ".", "contains", ";", "if", "(", "overlaps_", "(", "scl", ",", "dim_a", ",", "dim_b", ")", ")", "return", "RelationalOperations", ".", "Relation", ".", "overlaps", ";", "return", "RelationalOperations", ".", "Relation", ".", "unknown", ";", "}"], "docstring": "Checks whether scl string is a predefined relation.", "docstring_tokens": ["Checks", "whether", "scl", "string", "is", "a", "predefined", "relation", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java#L1122-L1142", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java", "func_name": "RelationalOperationsMatrix.equals_", "original_string": "private static boolean equals_(String scl) {\n\t\t// Valid for all\n\t\tif (scl.charAt(0) == 'T' && scl.charAt(1) == '*'\n\t\t\t\t&& scl.charAt(2) == 'F' && scl.charAt(3) == '*'\n\t\t\t\t&& scl.charAt(4) == '*' && scl.charAt(5) == 'F'\n\t\t\t\t&& scl.charAt(6) == 'F' && scl.charAt(7) == 'F'\n\t\t\t\t&& scl.charAt(8) == '*')\n\t\t\treturn true;\n\n\t\treturn false;\n\t}", "language": "java", "code": "private static boolean equals_(String scl) {\n\t\t// Valid for all\n\t\tif (scl.charAt(0) == 'T' && scl.charAt(1) == '*'\n\t\t\t\t&& scl.charAt(2) == 'F' && scl.charAt(3) == '*'\n\t\t\t\t&& scl.charAt(4) == '*' && scl.charAt(5) == 'F'\n\t\t\t\t&& scl.charAt(6) == 'F' && scl.charAt(7) == 'F'\n\t\t\t\t&& scl.charAt(8) == '*')\n\t\t\treturn true;\n\n\t\treturn false;\n\t}", "code_tokens": ["private", "static", "boolean", "equals_", "(", "String", "scl", ")", "{", "// Valid for all", "if", "(", "scl", ".", "charAt", "(", "0", ")", "==", "'", "'", "&&", "scl", ".", "charAt", "(", "1", ")", "==", "'", "'", "&&", "scl", ".", "charAt", "(", "2", ")", "==", "'", "'", "&&", "scl", ".", "charAt", "(", "3", ")", "==", "'", "'", "&&", "scl", ".", "charAt", "(", "4", ")", "==", "'", "'", "&&", "scl", ".", "charAt", "(", "5", ")", "==", "'", "'", "&&", "scl", ".", "charAt", "(", "6", ")", "==", "'", "'", "&&", "scl", ".", "charAt", "(", "7", ")", "==", "'", "'", "&&", "scl", ".", "charAt", "(", "8", ")", "==", "'", "'", ")", "return", "true", ";", "return", "false", ";", "}"], "docstring": "Checks whether the scl string is the equals relation.", "docstring_tokens": ["Checks", "whether", "the", "scl", "string", "is", "the", "equals", "relation", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java#L1145-L1155", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java", "func_name": "RelationalOperationsMatrix.areaPointPredicates_", "original_string": "private boolean areaPointPredicates_(int cluster, int id_a, int id_b) {\n        boolean bRelationKnown = true;\n\n        if (m_perform_predicates[MatrixPredicate.InteriorInterior])\n        {\n            interiorAreaInteriorPoint_(cluster, id_a);\n            bRelationKnown &= isPredicateKnown_(MatrixPredicate.InteriorInterior);\n        }\n\n        if (m_perform_predicates[MatrixPredicate.InteriorExterior])\n        {\n            interiorAreaExteriorPoint_(cluster, id_a);\n            bRelationKnown &= isPredicateKnown_(MatrixPredicate.InteriorExterior);\n        }\n\n        if (m_perform_predicates[MatrixPredicate.BoundaryInterior])\n        {\n            boundaryAreaInteriorPoint_(cluster, id_a, id_b);\n            bRelationKnown &= isPredicateKnown_(MatrixPredicate.BoundaryInterior);\n        }\n\n        if (m_perform_predicates[MatrixPredicate.BoundaryExterior])\n        {\n            boundaryAreaExteriorPoint_(cluster, id_a);\n            bRelationKnown &= isPredicateKnown_(MatrixPredicate.BoundaryExterior);\n        }\n\n        if (m_perform_predicates[MatrixPredicate.ExteriorInterior])\n        {\n            exteriorAreaInteriorPoint_(cluster, id_a);\n            bRelationKnown &= isPredicateKnown_(MatrixPredicate.ExteriorInterior);\n        }\n\n        return bRelationKnown;\n\t}", "language": "java", "code": "private boolean areaPointPredicates_(int cluster, int id_a, int id_b) {\n        boolean bRelationKnown = true;\n\n        if (m_perform_predicates[MatrixPredicate.InteriorInterior])\n        {\n            interiorAreaInteriorPoint_(cluster, id_a);\n            bRelationKnown &= isPredicateKnown_(MatrixPredicate.InteriorInterior);\n        }\n\n        if (m_perform_predicates[MatrixPredicate.InteriorExterior])\n        {\n            interiorAreaExteriorPoint_(cluster, id_a);\n            bRelationKnown &= isPredicateKnown_(MatrixPredicate.InteriorExterior);\n        }\n\n        if (m_perform_predicates[MatrixPredicate.BoundaryInterior])\n        {\n            boundaryAreaInteriorPoint_(cluster, id_a, id_b);\n            bRelationKnown &= isPredicateKnown_(MatrixPredicate.BoundaryInterior);\n        }\n\n        if (m_perform_predicates[MatrixPredicate.BoundaryExterior])\n        {\n            boundaryAreaExteriorPoint_(cluster, id_a);\n            bRelationKnown &= isPredicateKnown_(MatrixPredicate.BoundaryExterior);\n        }\n\n        if (m_perform_predicates[MatrixPredicate.ExteriorInterior])\n        {\n            exteriorAreaInteriorPoint_(cluster, id_a);\n            bRelationKnown &= isPredicateKnown_(MatrixPredicate.ExteriorInterior);\n        }\n\n        return bRelationKnown;\n\t}", "code_tokens": ["private", "boolean", "areaPointPredicates_", "(", "int", "cluster", ",", "int", "id_a", ",", "int", "id_b", ")", "{", "boolean", "bRelationKnown", "=", "true", ";", "if", "(", "m_perform_predicates", "[", "MatrixPredicate", ".", "InteriorInterior", "]", ")", "{", "interiorAreaInteriorPoint_", "(", "cluster", ",", "id_a", ")", ";", "bRelationKnown", "&=", "isPredicateKnown_", "(", "MatrixPredicate", ".", "InteriorInterior", ")", ";", "}", "if", "(", "m_perform_predicates", "[", "MatrixPredicate", ".", "InteriorExterior", "]", ")", "{", "interiorAreaExteriorPoint_", "(", "cluster", ",", "id_a", ")", ";", "bRelationKnown", "&=", "isPredicateKnown_", "(", "MatrixPredicate", ".", "InteriorExterior", ")", ";", "}", "if", "(", "m_perform_predicates", "[", "MatrixPredicate", ".", "BoundaryInterior", "]", ")", "{", "boundaryAreaInteriorPoint_", "(", "cluster", ",", "id_a", ",", "id_b", ")", ";", "bRelationKnown", "&=", "isPredicateKnown_", "(", "MatrixPredicate", ".", "BoundaryInterior", ")", ";", "}", "if", "(", "m_perform_predicates", "[", "MatrixPredicate", ".", "BoundaryExterior", "]", ")", "{", "boundaryAreaExteriorPoint_", "(", "cluster", ",", "id_a", ")", ";", "bRelationKnown", "&=", "isPredicateKnown_", "(", "MatrixPredicate", ".", "BoundaryExterior", ")", ";", "}", "if", "(", "m_perform_predicates", "[", "MatrixPredicate", ".", "ExteriorInterior", "]", ")", "{", "exteriorAreaInteriorPoint_", "(", "cluster", ",", "id_a", ")", ";", "bRelationKnown", "&=", "isPredicateKnown_", "(", "MatrixPredicate", ".", "ExteriorInterior", ")", ";", "}", "return", "bRelationKnown", ";", "}"], "docstring": "Invokes the 9 relational predicates of area vs Point.", "docstring_tokens": ["Invokes", "the", "9", "relational", "predicates", "of", "area", "vs", "Point", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/RelationalOperationsMatrix.java#L1981-L2015", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/TopoGraph.java", "func_name": "TopoGraph.createUserIndexForClusters", "original_string": "int createUserIndexForClusters() {\n\t\tif (m_clusterIndices == null) {\n\t\t\tm_clusterIndices = new ArrayList<AttributeStreamOfInt32>(3);\n\t\t}\n\n\t\tAttributeStreamOfInt32 new_stream = new AttributeStreamOfInt32(\n\t\t\t\tm_clusterData.capacity(), -1);\n\t\tfor (int i = 0, n = m_clusterIndices.size(); i < n; i++) {\n\t\t\tif (m_clusterIndices.get(i) == null) {\n\t\t\t\tm_clusterIndices.set(i, new_stream);\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\tm_clusterIndices.add(new_stream);\n\t\treturn m_clusterIndices.size() - 1;\n\t}", "language": "java", "code": "int createUserIndexForClusters() {\n\t\tif (m_clusterIndices == null) {\n\t\t\tm_clusterIndices = new ArrayList<AttributeStreamOfInt32>(3);\n\t\t}\n\n\t\tAttributeStreamOfInt32 new_stream = new AttributeStreamOfInt32(\n\t\t\t\tm_clusterData.capacity(), -1);\n\t\tfor (int i = 0, n = m_clusterIndices.size(); i < n; i++) {\n\t\t\tif (m_clusterIndices.get(i) == null) {\n\t\t\t\tm_clusterIndices.set(i, new_stream);\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\tm_clusterIndices.add(new_stream);\n\t\treturn m_clusterIndices.size() - 1;\n\t}", "code_tokens": ["int", "createUserIndexForClusters", "(", ")", "{", "if", "(", "m_clusterIndices", "==", "null", ")", "{", "m_clusterIndices", "=", "new", "ArrayList", "<", "AttributeStreamOfInt32", ">", "(", "3", ")", ";", "}", "AttributeStreamOfInt32", "new_stream", "=", "new", "AttributeStreamOfInt32", "(", "m_clusterData", ".", "capacity", "(", ")", ",", "-", "1", ")", ";", "for", "(", "int", "i", "=", "0", ",", "n", "=", "m_clusterIndices", ".", "size", "(", ")", ";", "i", "<", "n", ";", "i", "++", ")", "{", "if", "(", "m_clusterIndices", ".", "get", "(", "i", ")", "==", "null", ")", "{", "m_clusterIndices", ".", "set", "(", "i", ",", "new_stream", ")", ";", "return", "i", ";", "}", "}", "m_clusterIndices", ".", "add", "(", "new_stream", ")", ";", "return", "m_clusterIndices", ".", "size", "(", ")", "-", "1", ";", "}"], "docstring": "Creates a new user index for the cluster. The index values are set to -1.", "docstring_tokens": ["Creates", "a", "new", "user", "index", "for", "the", "cluster", ".", "The", "index", "values", "are", "set", "to", "-", "1", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/TopoGraph.java#L2037-L2052", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/TopoGraph.java", "func_name": "TopoGraph.deleteEdgeInternal_", "original_string": "int deleteEdgeInternal_(int half_edge) {\n\t\tint chain = getHalfEdgeChain(half_edge);\n\t\tint halfEdgeTwin = getHalfEdgeTwin(half_edge);\n\t\tint chainTwin = getHalfEdgeChain(halfEdgeTwin);\n\t\t// This function only works for spikes. These two asserts check for that\n\t\tassert (chainTwin == chain);\n\t\tassert (half_edge == getHalfEdgeNext(halfEdgeTwin) || halfEdgeTwin == getHalfEdgeNext(half_edge));\n\n\t\tint n = getHalfEdgeNext(half_edge);\n\t\tif (n == halfEdgeTwin) {\n\t\t\tn = getHalfEdgeNext(n);\n\t\t\tif (n == half_edge)\n\t\t\t\tn = -1;\n\t\t}\n\n\t\tif (getChainHalfEdge(chain) == half_edge) {\n\t\t\tsetChainHalfEdge_(chain, n);\n\t\t}\n\n\t\tint chainIndex = getChainIndex_(chain);\n\t\tdouble v = m_chainAreas.read(chainIndex);\n\t\tif (!NumberUtils.isNaN(v)) {\n\t\t\tsetChainArea_(chain, NumberUtils.TheNaN);\n\t\t\tsetChainPerimeter_(chain, NumberUtils.TheNaN);\n\t\t}\n\n\t\tupdateVertexToHalfEdgeConnection_(half_edge, true);\n\n\t\tdeleteEdgeImpl_(half_edge);// does not change chain information\n\t\treturn n;\n\t}", "language": "java", "code": "int deleteEdgeInternal_(int half_edge) {\n\t\tint chain = getHalfEdgeChain(half_edge);\n\t\tint halfEdgeTwin = getHalfEdgeTwin(half_edge);\n\t\tint chainTwin = getHalfEdgeChain(halfEdgeTwin);\n\t\t// This function only works for spikes. These two asserts check for that\n\t\tassert (chainTwin == chain);\n\t\tassert (half_edge == getHalfEdgeNext(halfEdgeTwin) || halfEdgeTwin == getHalfEdgeNext(half_edge));\n\n\t\tint n = getHalfEdgeNext(half_edge);\n\t\tif (n == halfEdgeTwin) {\n\t\t\tn = getHalfEdgeNext(n);\n\t\t\tif (n == half_edge)\n\t\t\t\tn = -1;\n\t\t}\n\n\t\tif (getChainHalfEdge(chain) == half_edge) {\n\t\t\tsetChainHalfEdge_(chain, n);\n\t\t}\n\n\t\tint chainIndex = getChainIndex_(chain);\n\t\tdouble v = m_chainAreas.read(chainIndex);\n\t\tif (!NumberUtils.isNaN(v)) {\n\t\t\tsetChainArea_(chain, NumberUtils.TheNaN);\n\t\t\tsetChainPerimeter_(chain, NumberUtils.TheNaN);\n\t\t}\n\n\t\tupdateVertexToHalfEdgeConnection_(half_edge, true);\n\n\t\tdeleteEdgeImpl_(half_edge);// does not change chain information\n\t\treturn n;\n\t}", "code_tokens": ["int", "deleteEdgeInternal_", "(", "int", "half_edge", ")", "{", "int", "chain", "=", "getHalfEdgeChain", "(", "half_edge", ")", ";", "int", "halfEdgeTwin", "=", "getHalfEdgeTwin", "(", "half_edge", ")", ";", "int", "chainTwin", "=", "getHalfEdgeChain", "(", "halfEdgeTwin", ")", ";", "// This function only works for spikes. These two asserts check for that", "assert", "(", "chainTwin", "==", "chain", ")", ";", "assert", "(", "half_edge", "==", "getHalfEdgeNext", "(", "halfEdgeTwin", ")", "||", "halfEdgeTwin", "==", "getHalfEdgeNext", "(", "half_edge", ")", ")", ";", "int", "n", "=", "getHalfEdgeNext", "(", "half_edge", ")", ";", "if", "(", "n", "==", "halfEdgeTwin", ")", "{", "n", "=", "getHalfEdgeNext", "(", "n", ")", ";", "if", "(", "n", "==", "half_edge", ")", "n", "=", "-", "1", ";", "}", "if", "(", "getChainHalfEdge", "(", "chain", ")", "==", "half_edge", ")", "{", "setChainHalfEdge_", "(", "chain", ",", "n", ")", ";", "}", "int", "chainIndex", "=", "getChainIndex_", "(", "chain", ")", ";", "double", "v", "=", "m_chainAreas", ".", "read", "(", "chainIndex", ")", ";", "if", "(", "!", "NumberUtils", ".", "isNaN", "(", "v", ")", ")", "{", "setChainArea_", "(", "chain", ",", "NumberUtils", ".", "TheNaN", ")", ";", "setChainPerimeter_", "(", "chain", ",", "NumberUtils", ".", "TheNaN", ")", ";", "}", "updateVertexToHalfEdgeConnection_", "(", "half_edge", ",", "true", ")", ";", "deleteEdgeImpl_", "(", "half_edge", ")", ";", "// does not change chain information", "return", "n", ";", "}"], "docstring": "Use with care.", "docstring_tokens": ["Use", "with", "care", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/TopoGraph.java#L2166-L2196", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/QuadTreeImpl.java", "func_name": "QuadTreeImpl.removeElement", "original_string": "void removeElement(int element_handle) {\n\t\tif (m_b_store_duplicates)\n\t\t\tthrow new GeometryException(\"invalid call\");\n\n\t\tint quad_handle = get_quad_(element_handle);\n\t\tdisconnect_element_handle_(element_handle);\n\t\tfree_element_and_box_node_(element_handle);\n\n\t\tint q = quad_handle;\n\n\t\twhile (q != -1) {\n\t\t\tset_sub_tree_element_count_(q, get_sub_tree_element_count_(q) - 1);\n\t\t\tint parent = get_parent_(q);\n\n\t\t\tif (get_sub_tree_element_count_(q) == 0) {\n\t\t\t\tassert (get_local_element_count_(q) == 0);\n\n\t\t\t\tif (q != m_root) {\n\t\t\t\t\tint quadrant = get_quadrant_(q);\n\t\t\t\t\tm_quad_tree_nodes.deleteElement(q);\n\t\t\t\t\tset_child_(parent, quadrant, -1);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tq = parent;\n\t\t}\n\t}", "language": "java", "code": "void removeElement(int element_handle) {\n\t\tif (m_b_store_duplicates)\n\t\t\tthrow new GeometryException(\"invalid call\");\n\n\t\tint quad_handle = get_quad_(element_handle);\n\t\tdisconnect_element_handle_(element_handle);\n\t\tfree_element_and_box_node_(element_handle);\n\n\t\tint q = quad_handle;\n\n\t\twhile (q != -1) {\n\t\t\tset_sub_tree_element_count_(q, get_sub_tree_element_count_(q) - 1);\n\t\t\tint parent = get_parent_(q);\n\n\t\t\tif (get_sub_tree_element_count_(q) == 0) {\n\t\t\t\tassert (get_local_element_count_(q) == 0);\n\n\t\t\t\tif (q != m_root) {\n\t\t\t\t\tint quadrant = get_quadrant_(q);\n\t\t\t\t\tm_quad_tree_nodes.deleteElement(q);\n\t\t\t\t\tset_child_(parent, quadrant, -1);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tq = parent;\n\t\t}\n\t}", "code_tokens": ["void", "removeElement", "(", "int", "element_handle", ")", "{", "if", "(", "m_b_store_duplicates", ")", "throw", "new", "GeometryException", "(", "\"invalid call\"", ")", ";", "int", "quad_handle", "=", "get_quad_", "(", "element_handle", ")", ";", "disconnect_element_handle_", "(", "element_handle", ")", ";", "free_element_and_box_node_", "(", "element_handle", ")", ";", "int", "q", "=", "quad_handle", ";", "while", "(", "q", "!=", "-", "1", ")", "{", "set_sub_tree_element_count_", "(", "q", ",", "get_sub_tree_element_count_", "(", "q", ")", "-", "1", ")", ";", "int", "parent", "=", "get_parent_", "(", "q", ")", ";", "if", "(", "get_sub_tree_element_count_", "(", "q", ")", "==", "0", ")", "{", "assert", "(", "get_local_element_count_", "(", "q", ")", "==", "0", ")", ";", "if", "(", "q", "!=", "m_root", ")", "{", "int", "quadrant", "=", "get_quadrant_", "(", "q", ")", ";", "m_quad_tree_nodes", ".", "deleteElement", "(", "q", ")", ";", "set_child_", "(", "parent", ",", "quadrant", ",", "-", "1", ")", ";", "}", "}", "q", "=", "parent", ";", "}", "}"], "docstring": "Removes the element and bounding_box at the given element_handle.\nNote that this will invalidate any active iterator on the Quad_tree_impl.\n\\param element_handle The handle corresponding to the element and bounding_box to be removed.", "docstring_tokens": ["Removes", "the", "element", "and", "bounding_box", "at", "the", "given", "element_handle", ".", "Note", "that", "this", "will", "invalidate", "any", "active", "iterator", "on", "the", "Quad_tree_impl", ".", "\\", "param", "element_handle", "The", "handle", "corresponding", "to", "the", "element", "and", "bounding_box", "to", "be", "removed", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/QuadTreeImpl.java#L461-L487", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/Envelope2D.java", "func_name": "Envelope2D.mergeNE", "original_string": "public void mergeNE(double x, double y) {\n\t\tif (xmin > x)\n\t\t\txmin = x;\n\t\telse if (xmax < x)\n\t\t\txmax = x;\n\n\t\tif (ymin > y)\n\t\t\tymin = y;\n\t\telse if (ymax < y)\n\t\t\tymax = y;\n\t}", "language": "java", "code": "public void mergeNE(double x, double y) {\n\t\tif (xmin > x)\n\t\t\txmin = x;\n\t\telse if (xmax < x)\n\t\t\txmax = x;\n\n\t\tif (ymin > y)\n\t\t\tymin = y;\n\t\telse if (ymax < y)\n\t\t\tymax = y;\n\t}", "code_tokens": ["public", "void", "mergeNE", "(", "double", "x", ",", "double", "y", ")", "{", "if", "(", "xmin", ">", "x", ")", "xmin", "=", "x", ";", "else", "if", "(", "xmax", "<", "x", ")", "xmax", "=", "x", ";", "if", "(", "ymin", ">", "y", ")", "ymin", "=", "y", ";", "else", "if", "(", "ymax", "<", "y", ")", "ymax", "=", "y", ";", "}"], "docstring": "Merges a point with this envelope without checking if the envelope is\nempty. Use with care.\n@param x The x coord of the point\n@param y the y coord in the point", "docstring_tokens": ["Merges", "a", "point", "with", "this", "envelope", "without", "checking", "if", "the", "envelope", "is", "empty", ".", "Use", "with", "care", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/Envelope2D.java#L205-L215", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/Envelope2D.java", "func_name": "Envelope2D.queryCorners", "original_string": "public void queryCorners(Point2D[] corners) {\n\t\tif ((corners == null) || (corners.length < 4))\n\t\t\tthrow new IllegalArgumentException();\n\t\tif (corners[0] != null)\n\t\t\tcorners[0].setCoords(xmin, ymin);\n\t\telse\n\t\t\tcorners[0] = new Point2D(xmin, ymin);\n\n\t\tif (corners[1] != null)\n\t\t\tcorners[1].setCoords(xmin, ymax);\n\t\telse\n\t\t\tcorners[1] = new Point2D(xmin, ymax);\n\n\t\tif (corners[2] != null)\n\t\t\tcorners[2].setCoords(xmax, ymax);\n\t\telse\n\t\t\tcorners[2] = new Point2D(xmax, ymax);\n\n\t\tif (corners[3] != null)\n\t\t\tcorners[3].setCoords(xmax, ymin);\n\t\telse\n\t\t\tcorners[3] = new Point2D(xmax, ymin);\n\t}", "language": "java", "code": "public void queryCorners(Point2D[] corners) {\n\t\tif ((corners == null) || (corners.length < 4))\n\t\t\tthrow new IllegalArgumentException();\n\t\tif (corners[0] != null)\n\t\t\tcorners[0].setCoords(xmin, ymin);\n\t\telse\n\t\t\tcorners[0] = new Point2D(xmin, ymin);\n\n\t\tif (corners[1] != null)\n\t\t\tcorners[1].setCoords(xmin, ymax);\n\t\telse\n\t\t\tcorners[1] = new Point2D(xmin, ymax);\n\n\t\tif (corners[2] != null)\n\t\t\tcorners[2].setCoords(xmax, ymax);\n\t\telse\n\t\t\tcorners[2] = new Point2D(xmax, ymax);\n\n\t\tif (corners[3] != null)\n\t\t\tcorners[3].setCoords(xmax, ymin);\n\t\telse\n\t\t\tcorners[3] = new Point2D(xmax, ymin);\n\t}", "code_tokens": ["public", "void", "queryCorners", "(", "Point2D", "[", "]", "corners", ")", "{", "if", "(", "(", "corners", "==", "null", ")", "||", "(", "corners", ".", "length", "<", "4", ")", ")", "throw", "new", "IllegalArgumentException", "(", ")", ";", "if", "(", "corners", "[", "0", "]", "!=", "null", ")", "corners", "[", "0", "]", ".", "setCoords", "(", "xmin", ",", "ymin", ")", ";", "else", "corners", "[", "0", "]", "=", "new", "Point2D", "(", "xmin", ",", "ymin", ")", ";", "if", "(", "corners", "[", "1", "]", "!=", "null", ")", "corners", "[", "1", "]", ".", "setCoords", "(", "xmin", ",", "ymax", ")", ";", "else", "corners", "[", "1", "]", "=", "new", "Point2D", "(", "xmin", ",", "ymax", ")", ";", "if", "(", "corners", "[", "2", "]", "!=", "null", ")", "corners", "[", "2", "]", ".", "setCoords", "(", "xmax", ",", "ymax", ")", ";", "else", "corners", "[", "2", "]", "=", "new", "Point2D", "(", "xmax", ",", "ymax", ")", ";", "if", "(", "corners", "[", "3", "]", "!=", "null", ")", "corners", "[", "3", "]", ".", "setCoords", "(", "xmax", ",", "ymin", ")", ";", "else", "corners", "[", "3", "]", "=", "new", "Point2D", "(", "xmax", ",", "ymin", ")", ";", "}"], "docstring": "Queries corners into a given array. The array length must be at least\n4. Starts from the lower left corner and goes clockwise.\n@param corners The array of four points.", "docstring_tokens": ["Queries", "corners", "into", "a", "given", "array", ".", "The", "array", "length", "must", "be", "at", "least", "4", ".", "Starts", "from", "the", "lower", "left", "corner", "and", "goes", "clockwise", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/Envelope2D.java#L386-L408", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/Envelope2D.java", "func_name": "Envelope2D._envelopeSide", "original_string": "int _envelopeSide(Point2D pt) {\n\n\t\tif (isEmpty())\n\t\t\treturn -1;\n\n\t\tdouble boundaryDist = _boundaryDistance(pt);\n\t\tdouble height = ymax - ymin;\n\t\tdouble width = xmax - xmin;\n\n\t\tif (boundaryDist < height)\n\t\t\treturn 0;\n\n\t\tif ((boundaryDist -= height) < width)\n\t\t\treturn 1;\n\n\t\treturn boundaryDist - width < height ? 2 : 3;\n\t}", "language": "java", "code": "int _envelopeSide(Point2D pt) {\n\n\t\tif (isEmpty())\n\t\t\treturn -1;\n\n\t\tdouble boundaryDist = _boundaryDistance(pt);\n\t\tdouble height = ymax - ymin;\n\t\tdouble width = xmax - xmin;\n\n\t\tif (boundaryDist < height)\n\t\t\treturn 0;\n\n\t\tif ((boundaryDist -= height) < width)\n\t\t\treturn 1;\n\n\t\treturn boundaryDist - width < height ? 2 : 3;\n\t}", "code_tokens": ["int", "_envelopeSide", "(", "Point2D", "pt", ")", "{", "if", "(", "isEmpty", "(", ")", ")", "return", "-", "1", ";", "double", "boundaryDist", "=", "_boundaryDistance", "(", "pt", ")", ";", "double", "height", "=", "ymax", "-", "ymin", ";", "double", "width", "=", "xmax", "-", "xmin", ";", "if", "(", "boundaryDist", "<", "height", ")", "return", "0", ";", "if", "(", "(", "boundaryDist", "-=", "height", ")", "<", "width", ")", "return", "1", ";", "return", "boundaryDist", "-", "width", "<", "height", "?", "2", ":", "3", ";", "}"], "docstring": "returns 0,..3 depending on which side pt lies.", "docstring_tokens": ["returns", "0", "..", "3", "depending", "on", "which", "side", "pt", "lies", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/Envelope2D.java#L792-L808", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/Envelope2D.java", "func_name": "Envelope2D.sqrMaxDistance", "original_string": "public double sqrMaxDistance(Envelope2D other) {\n\t\tif (isEmpty() || other.isEmpty())\n\t\t\treturn NumberUtils.TheNaN;\n\n\t\tdouble dist = 0;\n\t\tPoint2D[] points = new Point2D[4];\n\t\tqueryCorners(points);\n\t\tPoint2D[] points_o = new Point2D[4];\n\t\tother.queryCorners(points_o);\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\tdouble d = Point2D.sqrDistance(points[i], points_o[j]);\n\t\t\t\tif (d > dist) {\n\t\t\t\t\tdist = d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn dist;\n\t}", "language": "java", "code": "public double sqrMaxDistance(Envelope2D other) {\n\t\tif (isEmpty() || other.isEmpty())\n\t\t\treturn NumberUtils.TheNaN;\n\n\t\tdouble dist = 0;\n\t\tPoint2D[] points = new Point2D[4];\n\t\tqueryCorners(points);\n\t\tPoint2D[] points_o = new Point2D[4];\n\t\tother.queryCorners(points_o);\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\tdouble d = Point2D.sqrDistance(points[i], points_o[j]);\n\t\t\t\tif (d > dist) {\n\t\t\t\t\tdist = d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn dist;\n\t}", "code_tokens": ["public", "double", "sqrMaxDistance", "(", "Envelope2D", "other", ")", "{", "if", "(", "isEmpty", "(", ")", "||", "other", ".", "isEmpty", "(", ")", ")", "return", "NumberUtils", ".", "TheNaN", ";", "double", "dist", "=", "0", ";", "Point2D", "[", "]", "points", "=", "new", "Point2D", "[", "4", "]", ";", "queryCorners", "(", "points", ")", ";", "Point2D", "[", "]", "points_o", "=", "new", "Point2D", "[", "4", "]", ";", "other", ".", "queryCorners", "(", "points_o", ")", ";", "for", "(", "int", "i", "=", "0", ";", "i", "<", "4", ";", "i", "++", ")", "{", "for", "(", "int", "j", "=", "0", ";", "j", "<", "4", ";", "j", "++", ")", "{", "double", "d", "=", "Point2D", ".", "sqrDistance", "(", "points", "[", "i", "]", ",", "points_o", "[", "j", "]", ")", ";", "if", "(", "d", ">", "dist", ")", "{", "dist", "=", "d", ";", "}", "}", "}", "return", "dist", ";", "}"], "docstring": "Returns squared max distance between two bounding boxes. This is furthest distance between points on the two envelopes.\n\n@param other The bounding box to calculate the max distance two.\n@return Squared distance value.", "docstring_tokens": ["Returns", "squared", "max", "distance", "between", "two", "bounding", "boxes", ".", "This", "is", "furthest", "distance", "between", "points", "on", "the", "two", "envelopes", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/Envelope2D.java#L1191-L1210", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/MultiVertexGeometryImpl.java", "func_name": "MultiVertexGeometryImpl.getXYZ", "original_string": "@Override\n\tpublic Point3D getXYZ(int index) {\n\t\tif (index < 0 || index >= getPointCount())\n\t\t\tthrow new IndexOutOfBoundsException();\n\n\t\t_verifyAllStreams();\n\t\tAttributeStreamOfDbl v = (AttributeStreamOfDbl) m_vertexAttributes[0];\n\t\tPoint3D pt = new Point3D();\n\t\tpt.x = v.read(index * 2);\n\t\tpt.y = v.read(index * 2 + 1);\n\n\t\t// TODO check excluded if statement componenet\n\t\tif (hasAttribute(Semantics.Z))// && (m_vertexAttributes[1] != null))\n\t\t\tpt.z = m_vertexAttributes[1].readAsDbl(index);\n\t\telse\n\t\t\tpt.z = VertexDescription.getDefaultValue(Semantics.Z);\n\n\t\treturn pt;\n\t}", "language": "java", "code": "@Override\n\tpublic Point3D getXYZ(int index) {\n\t\tif (index < 0 || index >= getPointCount())\n\t\t\tthrow new IndexOutOfBoundsException();\n\n\t\t_verifyAllStreams();\n\t\tAttributeStreamOfDbl v = (AttributeStreamOfDbl) m_vertexAttributes[0];\n\t\tPoint3D pt = new Point3D();\n\t\tpt.x = v.read(index * 2);\n\t\tpt.y = v.read(index * 2 + 1);\n\n\t\t// TODO check excluded if statement componenet\n\t\tif (hasAttribute(Semantics.Z))// && (m_vertexAttributes[1] != null))\n\t\t\tpt.z = m_vertexAttributes[1].readAsDbl(index);\n\t\telse\n\t\t\tpt.z = VertexDescription.getDefaultValue(Semantics.Z);\n\n\t\treturn pt;\n\t}", "code_tokens": ["@", "Override", "public", "Point3D", "getXYZ", "(", "int", "index", ")", "{", "if", "(", "index", "<", "0", "||", "index", ">=", "getPointCount", "(", ")", ")", "throw", "new", "IndexOutOfBoundsException", "(", ")", ";", "_verifyAllStreams", "(", ")", ";", "AttributeStreamOfDbl", "v", "=", "(", "AttributeStreamOfDbl", ")", "m_vertexAttributes", "[", "0", "]", ";", "Point3D", "pt", "=", "new", "Point3D", "(", ")", ";", "pt", ".", "x", "=", "v", ".", "read", "(", "index", "*", "2", ")", ";", "pt", ".", "y", "=", "v", ".", "read", "(", "index", "*", "2", "+", "1", ")", ";", "// TODO check excluded if statement componenet", "if", "(", "hasAttribute", "(", "Semantics", ".", "Z", ")", ")", "// && (m_vertexAttributes[1] != null))", "pt", ".", "z", "=", "m_vertexAttributes", "[", "1", "]", ".", "readAsDbl", "(", "index", ")", ";", "else", "pt", ".", "z", "=", "VertexDescription", ".", "getDefaultValue", "(", "Semantics", ".", "Z", ")", ";", "return", "pt", ";", "}"], "docstring": "Checked vs. Jan 11, 2011", "docstring_tokens": ["Checked", "vs", ".", "Jan", "11", "2011"], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/MultiVertexGeometryImpl.java#L290-L308", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/MultiVertexGeometryImpl.java", "func_name": "MultiVertexGeometryImpl.QueryCoordinates", "original_string": "int QueryCoordinates(Point3D[] dst, int dstSize, int beginIndex,\n\t\t\tint endIndex) {\n\t\tint endIndexC = endIndex < 0 ? m_pointCount : endIndex;\n\t\tendIndexC = Math.min(endIndexC, beginIndex + dstSize);\n\n\t\tif (beginIndex < 0 || beginIndex >= m_pointCount\n\t\t\t\t|| endIndexC < beginIndex)\n\t\t\t// TODO replace geometry exc\n\t\t\tthrow new IllegalArgumentException();\n\n\t\tAttributeStreamOfDbl xy = (AttributeStreamOfDbl) getAttributeStreamRef(VertexDescription.Semantics.POSITION);\n\t\tAttributeStreamOfDbl z = null;\n\t\tdouble v = VertexDescription\n\t\t\t\t.getDefaultValue(VertexDescription.Semantics.Z);\n\t\tboolean bHasZ = hasAttribute(VertexDescription.Semantics.Z);\n\t\tif (bHasZ)\n\t\t\tz = (AttributeStreamOfDbl) getAttributeStreamRef(VertexDescription.Semantics.Z);\n\t\tint j = 0;\n\t\tfor (int i = beginIndex; i < endIndexC; i++, j++) {\n\t\t\tdst[j].x = xy.read(2 * i);\n\t\t\tdst[j].y = xy.read(2 * i + 1);\n\t\t\tdst[j].z = bHasZ ? z.read(i) : v;\n\n\t\t\tdst[j] = getXYZ(i);\n\t\t}\n\n\t\treturn endIndexC;\n\t}", "language": "java", "code": "int QueryCoordinates(Point3D[] dst, int dstSize, int beginIndex,\n\t\t\tint endIndex) {\n\t\tint endIndexC = endIndex < 0 ? m_pointCount : endIndex;\n\t\tendIndexC = Math.min(endIndexC, beginIndex + dstSize);\n\n\t\tif (beginIndex < 0 || beginIndex >= m_pointCount\n\t\t\t\t|| endIndexC < beginIndex)\n\t\t\t// TODO replace geometry exc\n\t\t\tthrow new IllegalArgumentException();\n\n\t\tAttributeStreamOfDbl xy = (AttributeStreamOfDbl) getAttributeStreamRef(VertexDescription.Semantics.POSITION);\n\t\tAttributeStreamOfDbl z = null;\n\t\tdouble v = VertexDescription\n\t\t\t\t.getDefaultValue(VertexDescription.Semantics.Z);\n\t\tboolean bHasZ = hasAttribute(VertexDescription.Semantics.Z);\n\t\tif (bHasZ)\n\t\t\tz = (AttributeStreamOfDbl) getAttributeStreamRef(VertexDescription.Semantics.Z);\n\t\tint j = 0;\n\t\tfor (int i = beginIndex; i < endIndexC; i++, j++) {\n\t\t\tdst[j].x = xy.read(2 * i);\n\t\t\tdst[j].y = xy.read(2 * i + 1);\n\t\t\tdst[j].z = bHasZ ? z.read(i) : v;\n\n\t\t\tdst[j] = getXYZ(i);\n\t\t}\n\n\t\treturn endIndexC;\n\t}", "code_tokens": ["int", "QueryCoordinates", "(", "Point3D", "[", "]", "dst", ",", "int", "dstSize", ",", "int", "beginIndex", ",", "int", "endIndex", ")", "{", "int", "endIndexC", "=", "endIndex", "<", "0", "?", "m_pointCount", ":", "endIndex", ";", "endIndexC", "=", "Math", ".", "min", "(", "endIndexC", ",", "beginIndex", "+", "dstSize", ")", ";", "if", "(", "beginIndex", "<", "0", "||", "beginIndex", ">=", "m_pointCount", "||", "endIndexC", "<", "beginIndex", ")", "// TODO replace geometry exc", "throw", "new", "IllegalArgumentException", "(", ")", ";", "AttributeStreamOfDbl", "xy", "=", "(", "AttributeStreamOfDbl", ")", "getAttributeStreamRef", "(", "VertexDescription", ".", "Semantics", ".", "POSITION", ")", ";", "AttributeStreamOfDbl", "z", "=", "null", ";", "double", "v", "=", "VertexDescription", ".", "getDefaultValue", "(", "VertexDescription", ".", "Semantics", ".", "Z", ")", ";", "boolean", "bHasZ", "=", "hasAttribute", "(", "VertexDescription", ".", "Semantics", ".", "Z", ")", ";", "if", "(", "bHasZ", ")", "z", "=", "(", "AttributeStreamOfDbl", ")", "getAttributeStreamRef", "(", "VertexDescription", ".", "Semantics", ".", "Z", ")", ";", "int", "j", "=", "0", ";", "for", "(", "int", "i", "=", "beginIndex", ";", "i", "<", "endIndexC", ";", "i", "++", ",", "j", "++", ")", "{", "dst", "[", "j", "]", ".", "x", "=", "xy", ".", "read", "(", "2", "*", "i", ")", ";", "dst", "[", "j", "]", ".", "y", "=", "xy", ".", "read", "(", "2", "*", "i", "+", "1", ")", ";", "dst", "[", "j", "]", ".", "z", "=", "bHasZ", "?", "z", ".", "read", "(", "i", ")", ":", "v", ";", "dst", "[", "j", "]", "=", "getXYZ", "(", "i", ")", ";", "}", "return", "endIndexC", ";", "}"], "docstring": "Checked vs. Jan 11, 2011", "docstring_tokens": ["Checked", "vs", ".", "Jan", "11", "2011"], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/MultiVertexGeometryImpl.java#L856-L883", "partition": "train"}
{"repo": "Esri/geometry-api-java", "path": "src/main/java/com/esri/core/geometry/PlaneSweepCrackerHelper.java", "func_name": "PlaneSweepCrackerHelper.disconnectEdgeFromCluster_", "original_string": "void disconnectEdgeFromCluster_(int edge, int cluster) {\n\t\tint next = getNextEdge(edge, cluster);\n\t\tassert (getPrevEdge(next, cluster) == edge);\n\t\tint prev = getPrevEdge(edge, cluster);\n\t\tassert (getNextEdge(prev, cluster) == edge);\n\t\tint first_edge = getClusterFirstEdge(cluster);\n\t\tif (next != edge) {\n\t\t\tsetNextEdge_(prev, cluster, next);\n\t\t\tsetPrevEdge_(next, cluster, prev);\n\t\t\tif (first_edge == edge)\n\t\t\t\tsetClusterFirstEdge_(cluster, next);\n\t\t} else\n\t\t\tsetClusterFirstEdge_(cluster, -1);\n\t}", "language": "java", "code": "void disconnectEdgeFromCluster_(int edge, int cluster) {\n\t\tint next = getNextEdge(edge, cluster);\n\t\tassert (getPrevEdge(next, cluster) == edge);\n\t\tint prev = getPrevEdge(edge, cluster);\n\t\tassert (getNextEdge(prev, cluster) == edge);\n\t\tint first_edge = getClusterFirstEdge(cluster);\n\t\tif (next != edge) {\n\t\t\tsetNextEdge_(prev, cluster, next);\n\t\t\tsetPrevEdge_(next, cluster, prev);\n\t\t\tif (first_edge == edge)\n\t\t\t\tsetClusterFirstEdge_(cluster, next);\n\t\t} else\n\t\t\tsetClusterFirstEdge_(cluster, -1);\n\t}", "code_tokens": ["void", "disconnectEdgeFromCluster_", "(", "int", "edge", ",", "int", "cluster", ")", "{", "int", "next", "=", "getNextEdge", "(", "edge", ",", "cluster", ")", ";", "assert", "(", "getPrevEdge", "(", "next", ",", "cluster", ")", "==", "edge", ")", ";", "int", "prev", "=", "getPrevEdge", "(", "edge", ",", "cluster", ")", ";", "assert", "(", "getNextEdge", "(", "prev", ",", "cluster", ")", "==", "edge", ")", ";", "int", "first_edge", "=", "getClusterFirstEdge", "(", "cluster", ")", ";", "if", "(", "next", "!=", "edge", ")", "{", "setNextEdge_", "(", "prev", ",", "cluster", ",", "next", ")", ";", "setPrevEdge_", "(", "next", ",", "cluster", ",", "prev", ")", ";", "if", "(", "first_edge", "==", "edge", ")", "setClusterFirstEdge_", "(", "cluster", ",", "next", ")", ";", "}", "else", "setClusterFirstEdge_", "(", "cluster", ",", "-", "1", ")", ";", "}"], "docstring": "Disconnects the edge from a cluster it is connected to.", "docstring_tokens": ["Disconnects", "the", "edge", "from", "a", "cluster", "it", "is", "connected", "to", "."], "sha": "494da8ec953d76e7c6072afbc081abfe48ff07cf", "url": "https://github.com/Esri/geometry-api-java/blob/494da8ec953d76e7c6072afbc081abfe48ff07cf/src/main/java/com/esri/core/geometry/PlaneSweepCrackerHelper.java#L571-L584", "partition": "train"}
